{"version":3,"file":"data-table.cjs","sources":["../../../src/components/table/data-table.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n  TableSortableHead,\n  type SortDirection,\n} from \"@/components/table/table\"\nimport { Checkbox } from \"@/components/ui/checkbox\"\nimport { Input } from \"@/components/ui/input\"\nimport { RightIcon, DownIcon } from \"@/icons\"\n\n/** 편집 컴포넌트 Props */\nexport interface EditComponentProps<T, K extends keyof T = keyof T> {\n  /** 현재 값 */\n  value: T[K]\n  /** 값 변경 핸들러 */\n  onChange: (value: T[K]) => void\n  /** 편집 완료 핸들러 (Enter 시 호출 - 검증 후 저장) */\n  onComplete: () => void\n  /** 편집 취소 핸들러 (Escape 또는 blur 시 호출 - 원래 값으로 복원) */\n  onCancel: () => void\n  /** 해당 행 데이터 */\n  row: T\n  /** 검증 에러 메시지 */\n  error?: string\n}\n\n/** 검증 결과 타입 */\nexport type ValidationResult = true | string\n\n/** 컬럼 정의 */\nexport interface DataTableColumn<T> {\n  /** 데이터 접근 키 */\n  accessorKey: keyof T\n  /** 헤더 텍스트 */\n  header: string\n  /** 정렬 가능 여부 */\n  sortable?: boolean\n  /** 컬럼 고정 너비 (sticky 컬럼에 권장) */\n  width?: string | number\n  /** 컬럼 최소 너비 (유동적 너비에 권장) */\n  minWidth?: string | number\n  /** 셀 정렬 */\n  align?: \"left\" | \"center\" | \"right\"\n  /** 커스텀 셀 렌더러 */\n  cell?: (value: T[keyof T], row: T) => React.ReactNode\n  /** 편집 가능 여부 */\n  editable?: boolean\n  /** 커스텀 편집 컴포넌트 (기본: Input) */\n  editComponent?: (props: EditComponentProps<T>) => React.ReactNode\n  /** 값 검증 함수 (true: 통과, string: 에러 메시지) */\n  validate?: (value: T[keyof T], row: T) => ValidationResult\n  /** 고정 컬럼 (left: 왼쪽 고정, right: 오른쪽 고정) */\n  sticky?: \"left\" | \"right\"\n}\n\n/** 정렬 상태 */\nexport interface SortState<T> {\n  column: keyof T | null\n  direction: SortDirection\n}\n\n/** 확장 가능 행 설정 */\nexport interface ExpandableConfig<T> {\n  /** 확장 영역 렌더링 함수 */\n  expandedRowRender: (row: T) => React.ReactNode\n  /** 행이 확장 가능한지 여부를 결정하는 함수 (기본: 모든 행 확장 가능) */\n  rowExpandable?: (row: T) => boolean\n  /** 기본 확장된 행 ID 배열 */\n  defaultExpandedRowIds?: (string | number)[]\n  /** 확장된 행 ID 배열 (제어 컴포넌트) */\n  expandedRowIds?: (string | number)[]\n  /** 확장 상태 변경 핸들러 */\n  onExpandedChange?: (expandedRowIds: (string | number)[]) => void\n}\n\n/** 편집 중인 셀 상태 */\ninterface EditingCell<T> {\n  rowId: string | number\n  columnKey: keyof T\n  error?: string\n}\n\nexport interface DataTableProps<T extends { id: string | number }> {\n  /** 컬럼 정의 */\n  columns: DataTableColumn<T>[]\n  /** 데이터 배열 */\n  data: T[]\n  /** 선택 기능 활성화 */\n  selectable?: boolean\n  /** 선택된 행 ID 배열 */\n  selectedIds?: (string | number)[]\n  /** 선택 변경 핸들러 */\n  onSelectionChange?: (selectedIds: (string | number)[]) => void\n  /** 정렬 상태 */\n  sortState?: SortState<T>\n  /** 정렬 변경 핸들러 */\n  onSortChange?: (sortState: SortState<T>) => void\n  /** 행 클릭 핸들러 */\n  onRowClick?: (row: T) => void\n  /** 셀 값 변경 핸들러 */\n  onCellChange?: (rowId: string | number, columnKey: keyof T, value: T[keyof T]) => void\n  /** 확장 가능 행 설정 */\n  expandable?: ExpandableConfig<T>\n  /** 빈 데이터 메시지 */\n  emptyMessage?: string\n  /** 추가 className */\n  className?: string\n  /** 행 className 커스터마이즈 */\n  rowClassName?: (row: T) => string\n  /** 테이블 본문 최대 높이 (초과 시 내부 스크롤) */\n  maxHeight?: number | string\n}\n\n/** 기본 편집 컴포넌트 (Input) */\nfunction DefaultEditComponent<T>({\n  value,\n  onChange,\n  onComplete,\n  onCancel,\n  error,\n}: EditComponentProps<T>) {\n  const inputRef = React.useRef<HTMLInputElement>(null)\n\n  React.useEffect(() => {\n    inputRef.current?.focus()\n    inputRef.current?.select()\n  }, [])\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\") {\n      e.preventDefault()\n      onComplete()\n    } else if (e.key === \"Escape\") {\n      e.preventDefault()\n      onCancel()\n    }\n  }\n\n  return (\n    <div className=\"flex flex-col gap-0.5\">\n      <Input\n        ref={inputRef}\n        value={String(value ?? \"\")}\n        onChange={(e) => onChange(e.target.value as T[keyof T])}\n        onKeyDown={handleKeyDown}\n        error={!!error}\n        className=\"w-full min-w-[60px] px-2 text-xs\"\n      />\n      {error && (\n        <span className=\"text-[10px] text-destructive dark:text-red-400\">\n          {error}\n        </span>\n      )}\n    </div>\n  )\n}\n\nfunction DataTable<T extends { id: string | number }>({\n  columns,\n  data,\n  selectable = false,\n  selectedIds = [],\n  onSelectionChange,\n  sortState,\n  onSortChange,\n  onRowClick,\n  onCellChange,\n  expandable,\n  emptyMessage = \"데이터가 없습니다.\",\n  className,\n  rowClassName,\n  maxHeight,\n}: DataTableProps<T>) {\n  const [editingCell, setEditingCell] = React.useState<EditingCell<T> | null>(null)\n  const [editValue, setEditValue] = React.useState<T[keyof T] | null>(null)\n  // stale closure 방지용 ref\n  const editValueRef = React.useRef<T[keyof T] | null>(null)\n  // 바깥 클릭 감지용 ref\n  const editingCellRef = React.useRef<HTMLTableCellElement>(null)\n  const [internalExpandedIds, setInternalExpandedIds] = React.useState<(string | number)[]>(\n    expandable?.defaultExpandedRowIds ?? []\n  )\n\n  const expandedRowIds = expandable?.expandedRowIds ?? internalExpandedIds\n  const setExpandedRowIds = expandable?.onExpandedChange ?? setInternalExpandedIds\n\n  const isAllSelected = data.length > 0 && selectedIds.length === data.length\n  const isIndeterminate = selectedIds.length > 0 && !isAllSelected\n\n  const handleSelectAll = () => {\n    if (isAllSelected) {\n      onSelectionChange?.([])\n    } else {\n      onSelectionChange?.(data.map((row) => row.id))\n    }\n  }\n\n  const handleSelectRow = (id: string | number) => {\n    if (selectedIds.includes(id)) {\n      onSelectionChange?.(selectedIds.filter((i) => i !== id))\n    } else {\n      onSelectionChange?.([...selectedIds, id])\n    }\n  }\n\n  const handleSort = (column: keyof T) => {\n    if (!onSortChange) return\n\n    if (sortState?.column === column) {\n      if (sortState.direction === \"asc\") {\n        onSortChange({ column, direction: \"desc\" })\n      } else if (sortState.direction === \"desc\") {\n        onSortChange({ column: null, direction: null })\n      } else {\n        onSortChange({ column, direction: \"asc\" })\n      }\n    } else {\n      onSortChange({ column, direction: \"asc\" })\n    }\n  }\n\n  const getSortDirection = (column: keyof T): SortDirection => {\n    return sortState?.column === column ? sortState.direction : null\n  }\n\n  const getAlignClass = (align?: \"left\" | \"center\" | \"right\") => {\n    switch (align) {\n      case \"center\":\n        return \"text-center\"\n      case \"right\":\n        return \"text-right\"\n      default:\n        return \"text-left\"\n    }\n  }\n\n  const startEditing = (rowId: string | number, columnKey: keyof T, currentValue: T[keyof T]) => {\n    setEditingCell({ rowId, columnKey })\n    setEditValue(currentValue)\n    editValueRef.current = currentValue\n  }\n\n  const completeEditing = (column: DataTableColumn<T>, row: T) => {\n    // stale closure 방지를 위해 ref에서 읽음\n    const currentValue = editValueRef.current\n    if (!editingCell || currentValue === null) {\n      setEditingCell(null)\n      setEditValue(null)\n      editValueRef.current = null\n      return\n    }\n\n    if (column.validate) {\n      const result = column.validate(currentValue, row)\n      if (result !== true) {\n        setEditingCell({ ...editingCell, error: result })\n        return\n      }\n    }\n\n    if (onCellChange) {\n      onCellChange(editingCell.rowId, editingCell.columnKey, currentValue)\n    }\n    setEditingCell(null)\n    setEditValue(null)\n    editValueRef.current = null\n  }\n\n  const cancelEditing = React.useCallback(() => {\n    setEditingCell(null)\n    setEditValue(null)\n    editValueRef.current = null\n  }, [])\n\n  React.useEffect(() => {\n    if (!editingCell) return\n\n    const handleClickOutside = (e: MouseEvent) => {\n      const target = e.target as Node\n      if (editingCellRef.current?.contains(target)) return\n      // Radix 포털 (Select 드롭다운) 내부 클릭은 무시해야 함\n      const radixPortal = (target as Element).closest?.(\"[data-radix-popper-content-wrapper]\")\n      if (radixPortal) return\n      cancelEditing()\n    }\n\n    document.addEventListener(\"mousedown\", handleClickOutside)\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside)\n  }, [editingCell, cancelEditing])\n\n  const isEditing = (rowId: string | number, columnKey: keyof T) => {\n    return editingCell?.rowId === rowId && editingCell?.columnKey === columnKey\n  }\n\n  const isRowExpandable = (row: T) => {\n    if (!expandable) return false\n    if (expandable.rowExpandable) return expandable.rowExpandable(row)\n    return true\n  }\n\n  const isRowExpanded = (rowId: string | number) => {\n    return expandedRowIds.includes(rowId)\n  }\n\n  const toggleRowExpanded = (rowId: string | number) => {\n    if (isRowExpanded(rowId)) {\n      setExpandedRowIds(expandedRowIds.filter((id) => id !== rowId))\n    } else {\n      setExpandedRowIds([...expandedRowIds, rowId])\n    }\n  }\n\n  const totalColumns = columns.length + (selectable ? 1 : 0) + (expandable ? 1 : 0)\n\n  // Sticky 컬럼 위치 계산\n  const getStickyStyles = React.useMemo(() => {\n    // 컬럼 너비 추출 헬퍼 (width 우선, 없으면 minWidth)\n    const getColWidth = (col: DataTableColumn<T>): number => {\n      const w = col.width ?? col.minWidth\n      return typeof w === \"number\" ? w : parseInt(String(w) || \"150\", 10)\n    }\n\n    const leftColumns = columns.filter((col) => col.sticky === \"left\")\n    const rightColumns = columns.filter((col) => col.sticky === \"right\")\n\n    // 왼쪽 고정 컬럼 위치 계산 (체크박스, 확장 아이콘 컬럼 고려)\n    const checkboxWidth = selectable ? 48 : 0 // w-12 = 48px\n    const expandWidth = expandable ? 40 : 0 // w-10 = 40px\n    const baseLeftOffset = checkboxWidth + expandWidth\n\n    const leftPositions = new Map<keyof T, number>()\n    let currentLeft = baseLeftOffset\n    for (const col of leftColumns) {\n      leftPositions.set(col.accessorKey, currentLeft)\n      currentLeft += getColWidth(col)\n    }\n\n    // 오른쪽 고정 컬럼 위치 계산 (역순)\n    const rightPositions = new Map<keyof T, number>()\n    let currentRight = 0\n    for (let i = rightColumns.length - 1; i >= 0; i--) {\n      const col = rightColumns[i]\n      rightPositions.set(col.accessorKey, currentRight)\n      currentRight += getColWidth(col)\n    }\n\n    // 마지막 왼쪽/첫 번째 오른쪽 고정 컬럼 (그림자용)\n    const lastLeftSticky = leftColumns.length > 0 ? leftColumns[leftColumns.length - 1].accessorKey : null\n    const firstRightSticky = rightColumns.length > 0 ? rightColumns[0].accessorKey : null\n\n    return (column: DataTableColumn<T>, isHeader: boolean, isSelected?: boolean) => {\n      if (!column.sticky) return { style: {}, className: \"\" }\n\n      const isLastLeft = column.accessorKey === lastLeftSticky\n      const isFirstRight = column.accessorKey === firstRightSticky\n\n      // 컬럼 너비 (px 단위 문자열로 변환) - sticky는 고정 너비 필요\n      const colWidth = getColWidth(column)\n      const widthPx = `${colWidth}px`\n\n      const baseStyles: React.CSSProperties = {\n        position: \"sticky\",\n        zIndex: isHeader ? 20 : 10,\n        width: widthPx,\n        minWidth: widthPx,\n        maxWidth: widthPx,\n      }\n\n      if (column.sticky === \"left\") {\n        const leftPos = leftPositions.get(column.accessorKey) ?? 0\n        return {\n          style: {\n            ...baseStyles,\n            left: `${leftPos}px`,\n          },\n          // 헤더: 셀 단위 hover, 바디: 행 단위 hover (group-hover)\n          className: cn(\n            \"transition-colors\",\n            isHeader\n              ? \"bg-[#eaedf1] dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700\"\n              : isSelected\n                ? \"bg-blue-50 dark:bg-blue-900\"\n                : \"bg-slate-50 dark:bg-slate-900 group-hover:bg-slate-100 dark:group-hover:bg-slate-800\",\n            isLastLeft && \"shadow-[2px_0_4px_rgba(0,0,0,0.08)]\"\n          ),\n        }\n      }\n\n      const rightPos = rightPositions.get(column.accessorKey) ?? 0\n      return {\n        style: {\n          ...baseStyles,\n          right: `${rightPos}px`,\n        },\n        className: cn(\n          \"transition-colors\",\n          isHeader\n            ? \"bg-[#eaedf1] dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700\"\n            : isSelected\n              ? \"bg-blue-50 dark:bg-blue-900\"\n              : \"bg-slate-50 dark:bg-slate-900 group-hover:bg-slate-100 dark:group-hover:bg-slate-800\",\n          isFirstRight && \"shadow-[-2px_0_4px_rgba(0,0,0,0.08)]\"\n        ),\n      }\n    }\n  }, [columns, selectable, expandable])\n\n  // 체크박스/확장 컬럼도 sticky로 만들기 (왼쪽 고정 컬럼이 있을 때)\n  const hasLeftStickyColumns = columns.some((col) => col.sticky === \"left\")\n\n  // 체크박스/확장 컬럼 너비 상수\n  const CHECKBOX_WIDTH = 48 // w-12 = 48px\n  const EXPAND_WIDTH = 40 // w-10 = 40px\n\n  return (\n    <Table className={className} maxHeight={maxHeight}>\n      <TableHeader>\n        <TableRow>\n          {selectable && (\n            <TableHead\n              className=\"bg-[#eaedf1] dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700\"\n              style={hasLeftStickyColumns ? {\n                position: \"sticky\",\n                left: 0,\n                zIndex: 20,\n                width: `${CHECKBOX_WIDTH}px`,\n                minWidth: `${CHECKBOX_WIDTH}px`,\n                maxWidth: `${CHECKBOX_WIDTH}px`,\n              } : { width: `${CHECKBOX_WIDTH}px` }}\n            >\n              <Checkbox\n                checked={isAllSelected}\n                indeterminate={isIndeterminate}\n                onCheckedChange={handleSelectAll}\n                aria-label=\"전체 선택\"\n              />\n            </TableHead>\n          )}\n\n          {expandable && (\n            <TableHead\n              className=\"bg-[#eaedf1] dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700\"\n              style={hasLeftStickyColumns ? {\n                position: \"sticky\",\n                left: selectable ? CHECKBOX_WIDTH : 0,\n                zIndex: 20,\n                width: `${EXPAND_WIDTH}px`,\n                minWidth: `${EXPAND_WIDTH}px`,\n                maxWidth: `${EXPAND_WIDTH}px`,\n              } : { width: `${EXPAND_WIDTH}px` }}\n              aria-label=\"확장\"\n            >\n              <span className=\"sr-only\">확장</span>\n            </TableHead>\n          )}\n\n          {columns.map((column) => {\n            const stickyData = getStickyStyles(column, true)\n            // sticky 컬럼은 getStickyStyles에서 width/minWidth/maxWidth 모두 설정\n            // non-sticky 컬럼은 사용자가 지정한 width 또는 minWidth 사용\n            const toPx = (v: string | number) => typeof v === \"number\" ? `${v}px` : v\n            const baseStyle: React.CSSProperties = {}\n            if (!column.sticky) {\n              if (column.width) baseStyle.width = toPx(column.width)\n              if (column.minWidth) baseStyle.minWidth = toPx(column.minWidth)\n            }\n            const style = { ...baseStyle, ...stickyData.style }\n\n            if (column.sortable) {\n              return (\n                <TableSortableHead\n                  key={String(column.accessorKey)}\n                  sortDirection={getSortDirection(column.accessorKey)}\n                  onSort={() => handleSort(column.accessorKey)}\n                  style={style}\n                  className={cn(getAlignClass(column.align), stickyData.className)}\n                >\n                  {column.header}\n                </TableSortableHead>\n              )\n            }\n\n            return (\n              <TableHead\n                key={String(column.accessorKey)}\n                style={style}\n                className={cn(getAlignClass(column.align), stickyData.className)}\n              >\n                {column.header}\n              </TableHead>\n            )\n          })}\n        </TableRow>\n      </TableHeader>\n\n      <TableBody>\n        {data.length === 0 ? (\n          <TableRow>\n            <TableCell\n              colSpan={totalColumns}\n              className=\"h-24 text-center text-slate-500\"\n            >\n              {emptyMessage}\n            </TableCell>\n          </TableRow>\n        ) : (\n          data.map((row) => {\n            const isSelected = selectedIds.includes(row.id)\n            const canExpand = isRowExpandable(row)\n            const isExpanded = isRowExpanded(row.id)\n\n            return (\n              <React.Fragment key={row.id}>\n                <TableRow\n                  data-state={isSelected ? \"selected\" : undefined}\n                  className={cn(\n                    onRowClick && \"cursor-pointer\",\n                    rowClassName?.(row)\n                  )}\n                  onClick={() => onRowClick?.(row)}\n                >\n                  {selectable && (\n                    <TableCell\n                      onClick={(e) => e.stopPropagation()}\n                      className={hasLeftStickyColumns ? (isSelected ? \"transition-colors bg-blue-50 dark:bg-blue-900\" : \"transition-colors bg-slate-50 dark:bg-slate-900 group-hover:bg-slate-100 dark:group-hover:bg-slate-800\") : undefined}\n                      style={hasLeftStickyColumns ? {\n                        position: \"sticky\",\n                        left: 0,\n                        zIndex: 10,\n                        width: `${CHECKBOX_WIDTH}px`,\n                        minWidth: `${CHECKBOX_WIDTH}px`,\n                        maxWidth: `${CHECKBOX_WIDTH}px`,\n                      } : { width: `${CHECKBOX_WIDTH}px` }}\n                    >\n                      <Checkbox\n                        checked={isSelected}\n                        onCheckedChange={() => handleSelectRow(row.id)}\n                        aria-label={`행 ${row.id} 선택`}\n                      />\n                    </TableCell>\n                  )}\n\n                  {expandable && (\n                    <TableCell\n                      className={cn(\n                        \"p-0\",\n                        hasLeftStickyColumns && (isSelected ? \"transition-colors bg-blue-50 dark:bg-blue-900\" : \"transition-colors bg-slate-50 dark:bg-slate-900 group-hover:bg-slate-100 dark:group-hover:bg-slate-800\")\n                      )}\n                      style={hasLeftStickyColumns ? {\n                        position: \"sticky\",\n                        left: selectable ? CHECKBOX_WIDTH : 0,\n                        zIndex: 10,\n                        width: `${EXPAND_WIDTH}px`,\n                        minWidth: `${EXPAND_WIDTH}px`,\n                        maxWidth: `${EXPAND_WIDTH}px`,\n                      } : { width: `${EXPAND_WIDTH}px` }}\n                      onClick={(e) => e.stopPropagation()}\n                    >\n                      {canExpand && (\n                        <button\n                          type=\"button\"\n                          onClick={() => toggleRowExpanded(row.id)}\n                          className=\"flex h-9 w-10 items-center justify-center text-slate-400 hover:text-slate-600 dark:hover:text-slate-200 transition-colors\"\n                          aria-label={isExpanded ? \"행 접기\" : \"행 펼치기\"}\n                          aria-expanded={isExpanded}\n                        >\n                          {isExpanded ? (\n                            <DownIcon size={24} />\n                          ) : (\n                            <RightIcon size={24} />\n                          )}\n                        </button>\n                      )}\n                    </TableCell>\n                  )}\n\n                {columns.map((column) => {\n                  const value = row[column.accessorKey]\n                  const cellIsEditing = isEditing(row.id, column.accessorKey)\n                  const stickyData = getStickyStyles(column, false, isSelected)\n\n                  if (cellIsEditing && column.editable) {\n                    const EditComponent = column.editComponent || DefaultEditComponent\n\n                    return (\n                      <TableCell\n                        ref={editingCellRef}\n                        key={String(column.accessorKey)}\n                        className={cn(getAlignClass(column.align), \"p-1\", stickyData.className)}\n                        style={stickyData.style}\n                        onClick={(e) => e.stopPropagation()}\n                      >\n                        <EditComponent\n                          value={editValue as T[keyof T]}\n                          onChange={(newValue) => {\n                            setEditValue(newValue)\n                            // stale closure 방지\n                            editValueRef.current = newValue\n                            if (editingCell?.error) {\n                              setEditingCell({ ...editingCell, error: undefined })\n                            }\n                          }}\n                          onComplete={() => completeEditing(column, row)}\n                          onCancel={cancelEditing}\n                          row={row}\n                          error={editingCell?.error}\n                        />\n                      </TableCell>\n                    )\n                  }\n\n                  const content = column.cell\n                    ? column.cell(value, row)\n                    : String(value ?? \"\")\n\n                  if (column.editable && onCellChange) {\n                    return (\n                      <TableCell\n                        key={String(column.accessorKey)}\n                        className={cn(\n                          getAlignClass(column.align),\n                          \"cursor-text hover:bg-blue-100 dark:hover:bg-blue-800\",\n                          stickyData.className\n                        )}\n                        style={stickyData.style}\n                        onClick={(e) => {\n                          e.stopPropagation()\n                          // 이전 셀의 blur 처리가 먼저 완료되어야 함\n                          setTimeout(() => {\n                            startEditing(row.id, column.accessorKey, value)\n                          }, 0)\n                        }}\n                      >\n                        {content}\n                      </TableCell>\n                    )\n                  }\n\n                  return (\n                    <TableCell\n                      key={String(column.accessorKey)}\n                      className={cn(getAlignClass(column.align), stickyData.className)}\n                      style={stickyData.style}\n                    >\n                      {content}\n                    </TableCell>\n                  )\n                })}\n                </TableRow>\n\n                {expandable && isExpanded && (\n                  <TableRow className=\"bg-white dark:bg-slate-800/50 hover:bg-white dark:hover:bg-slate-800/50\">\n                    <TableCell\n                      colSpan={totalColumns}\n                      className=\"p-4\"\n                    >\n                      {expandable.expandedRowRender(row)}\n                    </TableCell>\n                  </TableRow>\n                )}\n              </React.Fragment>\n            )\n          })\n        )}\n      </TableBody>\n    </Table>\n  )\n}\n\nexport { DataTable }\n"],"names":["DefaultEditComponent","value","onChange","onComplete","onCancel","error","inputRef","React","_a","_b","handleKeyDown","e","jsxs","jsx","Input","DataTable","columns","data","selectable","selectedIds","onSelectionChange","sortState","onSortChange","onRowClick","onCellChange","expandable","emptyMessage","className","rowClassName","maxHeight","editingCell","setEditingCell","editValue","setEditValue","editValueRef","editingCellRef","internalExpandedIds","setInternalExpandedIds","expandedRowIds","setExpandedRowIds","isAllSelected","isIndeterminate","handleSelectAll","row","handleSelectRow","id","i","handleSort","column","getSortDirection","getAlignClass","align","startEditing","rowId","columnKey","currentValue","completeEditing","result","cancelEditing","handleClickOutside","target","isEditing","isRowExpandable","isRowExpanded","toggleRowExpanded","totalColumns","getStickyStyles","getColWidth","col","w","leftColumns","rightColumns","baseLeftOffset","leftPositions","currentLeft","rightPositions","currentRight","lastLeftSticky","firstRightSticky","isHeader","isSelected","isLastLeft","isFirstRight","widthPx","baseStyles","leftPos","cn","rightPos","hasLeftStickyColumns","CHECKBOX_WIDTH","EXPAND_WIDTH","Table","TableHeader","TableRow","TableHead","Checkbox","stickyData","toPx","v","baseStyle","style","TableSortableHead","TableBody","TableCell","canExpand","isExpanded","DownIcon","RightIcon","cellIsEditing","EditComponent","newValue","content"],"mappings":"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"}