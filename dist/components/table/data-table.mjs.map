{"version":3,"file":"data-table.mjs","sources":["../../../src/components/table/data-table.tsx"],"sourcesContent":["import * as React from \"react\"\nimport {\n  DndContext,\n  closestCenter,\n  KeyboardSensor,\n  PointerSensor,\n  useSensor,\n  useSensors,\n  type DragEndEvent,\n  type DraggableAttributes,\n} from \"@dnd-kit/core\"\nimport {\n  arrayMove,\n  SortableContext,\n  sortableKeyboardCoordinates,\n  horizontalListSortingStrategy,\n  verticalListSortingStrategy,\n  useSortable,\n} from \"@dnd-kit/sortable\"\nimport { CSS } from \"@dnd-kit/utilities\"\n\nimport { cn } from \"@/lib/utils\"\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n  TableSortableHead,\n  type SortDirection,\n} from \"@/components/table/table\"\nimport { Checkbox } from \"@/components/ui/checkbox\"\nimport { Input } from \"@/components/ui/input\"\nimport { Skeleton } from \"@/components/ui/skeleton\"\nimport { SplashScreen } from \"@/components/ui/splash-screen\"\nimport { RightIcon, DownIcon, DragHandleIcon, WriteIcon } from \"@/icons\"\n\n/** 편집 컴포넌트 Props */\nexport interface EditComponentProps<T, K extends keyof T = keyof T> {\n  /** 현재 값 */\n  value: T[K]\n  /** 값 변경 핸들러 */\n  onChange: (value: T[K]) => void\n  /** 편집 완료 핸들러 (Enter 시 호출 - 검증 후 저장) */\n  onComplete: () => void\n  /** 편집 취소 핸들러 (Escape 또는 blur 시 호출 - 원래 값으로 복원) */\n  onCancel: () => void\n  /** 해당 행 데이터 */\n  row: T\n  /** 검증 에러 메시지 */\n  error?: string\n}\n\n/** 검증 결과 타입 */\nexport type ValidationResult = true | string\n\n/** 컬럼 정의 */\nexport interface DataTableColumn<T> {\n  /** 데이터 접근 키 */\n  accessorKey: keyof T\n  /** 헤더 텍스트 */\n  header: React.ReactNode\n  /** 정렬 가능 여부 */\n  sortable?: boolean\n  /** 컬럼 고정 너비 (sticky 컬럼에 권장) */\n  width?: string | number\n  /** 컬럼 최소 너비 (width 미설정 시 남은 공간을 채움) */\n  minWidth?: string | number\n  /** 셀 정렬 */\n  align?: \"left\" | \"center\" | \"right\"\n  /** 커스텀 셀 렌더러 */\n  cell?: (value: T[keyof T], row: T) => React.ReactNode\n  /** 편집 가능 여부 */\n  editable?: boolean\n  /** 커스텀 편집 컴포넌트 (기본: Input) */\n  editComponent?: (props: EditComponentProps<T>) => React.ReactNode\n  /** 값 검증 함수 (true: 통과, string: 에러 메시지) */\n  validate?: (value: T[keyof T], row: T) => ValidationResult\n  /** 고정 컬럼 (left: 왼쪽 고정, right: 오른쪽 고정) */\n  sticky?: \"left\" | \"right\"\n}\n\n/** 헤더 그룹 정의 (다중 레벨 헤더) */\nexport interface HeaderGroup<T> {\n  /** 그룹 헤더 텍스트 */\n  header: React.ReactNode\n  /** 이 그룹에 포함되는 컬럼 키 배열 */\n  columns: (keyof T)[]\n  /** 정렬 */\n  align?: \"left\" | \"center\" | \"right\"\n}\n\n/** 로우 그룹핑 설정 */\nexport interface RowGroupConfig<T> {\n  /** 그룹핑할 컬럼 키 (해당 컬럼 값이 같은 행들은 셀이 병합됨) */\n  groupBy: keyof T | (keyof T)[]\n  /** 그룹핑 적용 컬럼들 (미지정 시 groupBy 컬럼만 병합) */\n  mergeColumns?: (keyof T)[]\n}\n\n/** 정렬 상태 */\nexport interface SortState<T> {\n  column: keyof T | null\n  direction: SortDirection\n}\n\n/** 확장 가능 행 설정 */\nexport interface ExpandableConfig<T> {\n  /** 확장 영역 렌더링 함수 */\n  expandedRowRender: (row: T) => React.ReactNode\n  /** 행이 확장 가능한지 여부를 결정하는 함수 (기본: 모든 행 확장 가능) */\n  rowExpandable?: (row: T) => boolean\n  /** 기본 확장된 행 ID 배열 */\n  defaultExpandedRowIds?: (string | number)[]\n  /** 확장된 행 ID 배열 (제어 컴포넌트) */\n  expandedRowIds?: (string | number)[]\n  /** 확장 상태 변경 핸들러 */\n  onExpandedChange?: (expandedRowIds: (string | number)[]) => void\n}\n\n/** 편집 중인 셀 상태 */\ninterface EditingCell<T> {\n  rowId: string | number\n  columnKey: keyof T\n  error?: string\n}\n\nexport interface DataTableProps<T extends { id: string | number }> {\n  /** 컬럼 정의 */\n  columns: DataTableColumn<T>[]\n  /** 데이터 배열 */\n  data: T[]\n  /** 선택 기능 활성화 */\n  selectable?: boolean\n  /** 선택된 행 ID 배열 */\n  selectedIds?: (string | number)[]\n  /** 선택 변경 핸들러 */\n  onSelectionChange?: (selectedIds: (string | number)[]) => void\n  /** 정렬 상태 */\n  sortState?: SortState<T>\n  /** 정렬 변경 핸들러 */\n  onSortChange?: (sortState: SortState<T>) => void\n  /** 행 클릭 핸들러 */\n  onRowClick?: (row: T) => void\n  /** 셀 값 변경 핸들러 */\n  onCellChange?: (rowId: string | number, columnKey: keyof T, value: T[keyof T]) => void\n  /** 확장 가능 행 설정 */\n  expandable?: ExpandableConfig<T>\n  /** 빈 데이터 메시지 */\n  emptyMessage?: React.ReactNode\n  /** 추가 className */\n  className?: string\n  /** 행 className 커스터마이즈 */\n  rowClassName?: (row: T) => string\n  /** 테이블 본문 최대 높이 (초과 시 내부 스크롤) */\n  maxHeight?: number | string\n  /** 컬럼 리사이징 활성화 */\n  resizable?: boolean\n  /** 컬럼 너비 상태 (제어 컴포넌트) */\n  columnWidths?: Record<string, number>\n  /** 컬럼 너비 변경 핸들러 */\n  onColumnResize?: (columnKey: keyof T, width: number) => void\n  /** 컬럼 순서 변경 활성화 */\n  columnReorderable?: boolean\n  /** 컬럼 순서 (accessorKey 배열) */\n  columnOrder?: (keyof T)[]\n  /** 컬럼 순서 변경 핸들러 */\n  onColumnReorder?: (newOrder: (keyof T)[]) => void\n  /** 로우 순서 변경 활성화 */\n  rowReorderable?: boolean\n  /** 로우 순서 변경 핸들러 */\n  onRowReorder?: (newData: T[]) => void\n  /** 로딩 상태 */\n  loading?: boolean\n  /** 로딩 모드 (splash: SplashScreen, skeleton: 컬럼 기반 스켈레톤 자동 생성) */\n  loadingMode?: \"splash\" | \"skeleton\"\n  /** 커스텀 로딩 콘텐츠 (loadingMode보다 우선 적용) */\n  loadingContent?: React.ReactNode\n  /** 헤더 그룹 정의 (다중 레벨 헤더) */\n  headerGroups?: HeaderGroup<T>[]\n  /** 로우 그룹핑 설정 (셀 병합) */\n  rowGrouping?: RowGroupConfig<T>\n}\n\n/** 기본 편집 컴포넌트 (Input) */\nfunction DefaultEditComponent<T>({\n  value,\n  onChange,\n  onComplete,\n  onCancel,\n  error,\n}: EditComponentProps<T>) {\n  const inputRef = React.useRef<HTMLInputElement>(null)\n\n  React.useEffect(() => {\n    inputRef.current?.focus()\n    inputRef.current?.select()\n  }, [])\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\") {\n      e.preventDefault()\n      onComplete()\n    } else if (e.key === \"Escape\") {\n      e.preventDefault()\n      onCancel()\n    }\n  }\n\n  return (\n    <div className=\"flex flex-col gap-0.5\">\n      <Input\n        ref={inputRef}\n        value={String(value ?? \"\")}\n        onChange={(e) => onChange(e.target.value as T[keyof T])}\n        onKeyDown={handleKeyDown}\n        error={!!error}\n        tableMode\n        className=\"w-full px-2 text-xs\"\n      />\n      {error && (\n        <span className=\"text-[10px] text-destructive dark:text-red-400\">\n          {error}\n        </span>\n      )}\n    </div>\n  )\n}\n\n/** 드래그 가능한 헤더 셀 */\ninterface SortableHeaderCellProps {\n  id: string\n  children: React.ReactNode\n  className?: string\n  style?: React.CSSProperties\n  disabled?: boolean\n}\n\nfunction SortableHeaderCell({\n  id,\n  children,\n  className,\n  style,\n  disabled,\n}: SortableHeaderCellProps) {\n  const {\n    attributes,\n    listeners,\n    setNodeRef,\n    transform,\n    transition,\n    isDragging,\n  } = useSortable({ id, disabled })\n\n  const dragStyle: React.CSSProperties = {\n    ...style,\n    transform: CSS.Transform.toString(transform),\n    transition,\n    opacity: isDragging ? 0.5 : 1,\n    cursor: disabled ? undefined : \"grab\",\n  }\n\n  return (\n    <th\n      ref={setNodeRef}\n      style={dragStyle}\n      className={cn(\n        \"group/drag h-9 pl-1.5 pr-1.5 py-1.5 text-left align-middle font-medium text-[#798698] dark:text-slate-300\",\n        \"bg-[#eaedf1] dark:bg-slate-800\",\n        \"[&:has([role=checkbox])]:pr-0\",\n        \"hover:bg-slate-200/70 dark:hover:bg-slate-700/70\",\n        \"transition-colors\",\n        isDragging && \"z-50\",\n        className\n      )}\n      {...attributes}\n      {...listeners}\n    >\n      <span className=\"flex items-center gap-0.5\">\n        <DragHandleIcon\n          size={16}\n          className=\"opacity-30 group-hover/drag:opacity-70 transition-opacity flex-shrink-0\"\n        />\n        {children}\n      </span>\n    </th>\n  )\n}\n\n/** 드래그 가능한 로우 */\ninterface SortableRowProps {\n  id: string\n  children: React.ReactNode | ((dragHandleProps: DragHandleProps) => React.ReactNode)\n  className?: string\n  isSelected?: boolean\n  onClick?: () => void\n  onMouseEnter?: () => void\n  onMouseLeave?: () => void\n}\n\ninterface DragHandleProps {\n  listeners?: Record<string, unknown>\n  attributes?: DraggableAttributes\n  setActivatorNodeRef?: (element: HTMLElement | null) => void\n}\n\nfunction SortableRow({\n  id,\n  children,\n  className,\n  isSelected,\n  onClick,\n  onMouseEnter,\n  onMouseLeave,\n}: SortableRowProps) {\n  const {\n    setNodeRef,\n    setActivatorNodeRef,\n    listeners,\n    attributes,\n    transform,\n    transition,\n    isDragging,\n  } = useSortable({ id })\n\n  const style: React.CSSProperties = {\n    transform: CSS.Transform.toString(transform),\n    transition,\n    opacity: isDragging ? 0.5 : 1,\n  }\n\n  return (\n    <tr\n      ref={setNodeRef}\n      style={style}\n      data-state={isSelected ? \"selected\" : undefined}\n      className={cn(\n        \"group border-b border-slate-200 dark:border-slate-700 transition-colors\",\n        \"bg-white dark:bg-slate-900 hover:bg-slate-100 dark:hover:bg-slate-800\",\n        \"data-[state=selected]:bg-blue-50 dark:data-[state=selected]:bg-blue-900\",\n        isDragging && \"z-50 shadow-lg\",\n        className\n      )}\n      onClick={onClick}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n    >\n      {typeof children === \"function\"\n        ? children({ listeners, attributes, setActivatorNodeRef })\n        : children}\n    </tr>\n  )\n}\n\n/** 드래그 핸들 셀 */\ninterface DragHandleCellProps {\n  isSelected?: boolean\n  hasLeftStickyColumns?: boolean\n  dragHandleProps?: DragHandleProps\n}\n\nfunction DragHandleCell({ isSelected, hasLeftStickyColumns, dragHandleProps }: DragHandleCellProps) {\n  const DRAG_HANDLE_WIDTH = 32\n  const { listeners, attributes, setActivatorNodeRef } = dragHandleProps ?? {}\n\n  return (\n    <td\n      className={cn(\n        \"p-0 align-middle\",\n        hasLeftStickyColumns && (isSelected\n          ? \"transition-colors bg-blue-50 dark:bg-blue-900\"\n          : \"transition-colors bg-slate-100 dark:bg-slate-800\"\n        )\n      )}\n      style={hasLeftStickyColumns ? {\n        position: \"sticky\",\n        left: 0,\n        zIndex: 10,\n        width: `${DRAG_HANDLE_WIDTH}px`,\n        minWidth: `${DRAG_HANDLE_WIDTH}px`,\n        maxWidth: `${DRAG_HANDLE_WIDTH}px`,\n      } : {\n        width: `${DRAG_HANDLE_WIDTH}px`,\n        minWidth: `${DRAG_HANDLE_WIDTH}px`,\n        maxWidth: `${DRAG_HANDLE_WIDTH}px`,\n      }}\n    >\n      <div\n        ref={setActivatorNodeRef}\n        className=\"flex h-9 w-8 items-center justify-center cursor-grab text-slate-400 hover:text-slate-600 dark:hover:text-slate-200 transition-colors\"\n        onClick={(e) => e.stopPropagation()}\n        aria-label=\"행 순서 변경\"\n        {...listeners}\n        {...attributes}\n      >\n        <DragHandleIcon size={16} />\n      </div>\n    </td>\n  )\n}\n\nfunction DataTable<T extends { id: string | number }>({\n  columns,\n  data,\n  selectable = false,\n  selectedIds = [],\n  onSelectionChange,\n  sortState,\n  onSortChange,\n  onRowClick,\n  onCellChange,\n  expandable,\n  emptyMessage = \"데이터가 없습니다.\",\n  className,\n  rowClassName,\n  maxHeight,\n  resizable = false,\n  columnWidths,\n  onColumnResize,\n  columnReorderable = false,\n  columnOrder,\n  onColumnReorder,\n  rowReorderable: rowReorderableProp = false,\n  onRowReorder,\n  loading = false,\n  loadingMode = \"splash\",\n  loadingContent,\n  headerGroups,\n  rowGrouping,\n}: DataTableProps<T>) {\n  // rowGrouping과 rowReorderable은 함께 사용할 수 없음 (rowSpan 셀 드래그 시 레이아웃 깨짐)\n  const rowReorderable = rowGrouping ? false : rowReorderableProp\n\n  React.useEffect(() => {\n    if (rowGrouping && rowReorderableProp) {\n      console.warn(\n        \"[DataTable] rowGrouping과 rowReorderable은 함께 사용할 수 없습니다. \" +\n        \"rowSpan 셀이 있는 행을 드래그하면 레이아웃이 깨지므로 rowReorderable이 무시됩니다.\"\n      )\n    }\n  }, [rowGrouping, rowReorderableProp])\n\n  React.useEffect(() => {\n    if (loadingContent && loadingMode !== \"splash\") {\n      console.warn(\n        \"[DataTable] loadingContent와 loadingMode가 함께 전달되었습니다. loadingContent가 우선 적용됩니다.\"\n      )\n    }\n  }, [loadingContent, loadingMode])\n\n  const [editingCell, setEditingCell] = React.useState<EditingCell<T> | null>(null)\n  const [editValue, setEditValue] = React.useState<T[keyof T] | null>(null)\n  // stale closure 방지용 ref\n  const editValueRef = React.useRef<T[keyof T] | null>(null)\n  // 바깥 클릭 감지용 ref\n  const editingCellRef = React.useRef<HTMLTableCellElement>(null)\n  const [internalExpandedIds, setInternalExpandedIds] = React.useState<(string | number)[]>(\n    expandable?.defaultExpandedRowIds ?? []\n  )\n  // 내부 컬럼 너비 상태 (비제어 컴포넌트용)\n  const [internalColumnWidths, setInternalColumnWidths] = React.useState<Record<string, number>>({})\n  // 리사이징 상태\n  const [resizingColumn, setResizingColumn] = React.useState<keyof T | null>(null)\n  const resizeStartX = React.useRef<number>(0)\n  const resizeStartWidth = React.useRef<number>(0)\n  // 내부 컬럼 순서 상태 (비제어 컴포넌트용)\n  const [internalColumnOrder, setInternalColumnOrder] = React.useState<(keyof T)[]>(() =>\n    columns.map((col) => col.accessorKey)\n  )\n  // 로우 그룹핑용 호버 상태 추적\n  const [hoveredRowIndex, setHoveredRowIndex] = React.useState<number | null>(null)\n\n  React.useEffect(() => {\n    if (!columnReorderable || columnOrder) return\n\n    setInternalColumnOrder((prev) => {\n      const columnKeys = columns.map((col) => col.accessorKey)\n      const next = prev.filter((key) => columnKeys.includes(key))\n      const missing = columnKeys.filter((key) => !next.includes(key))\n      const updated = [...next, ...missing]\n\n      if (\n        updated.length === prev.length &&\n        updated.every((key, index) => key === prev[index])\n      ) {\n        return prev\n      }\n\n      return updated\n    })\n  }, [columns, columnReorderable, columnOrder])\n\n  // 컬럼 순서 (제어/비제어)\n  const currentColumnOrder = columnOrder ?? internalColumnOrder\n  const orderedColumns = React.useMemo(() => {\n    if (!columnReorderable) return columns\n    return currentColumnOrder\n      .map((key) => columns.find((col) => col.accessorKey === key))\n      .filter((col): col is DataTableColumn<T> => col !== undefined)\n  }, [columns, currentColumnOrder, columnReorderable])\n\n  // dnd-kit 센서 설정\n  const sensors = useSensors(\n    useSensor(PointerSensor, {\n      activationConstraint: {\n        distance: 5, // 5px 이상 드래그해야 활성화\n      },\n    }),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    })\n  )\n\n  // 컬럼 드래그 완료 핸들러\n  const handleColumnDragEnd = React.useCallback(\n    (event: DragEndEvent) => {\n      const { active, over } = event\n      if (!over || active.id === over.id) return\n\n      const oldIndex = currentColumnOrder.findIndex((key) => String(key) === active.id)\n      const newIndex = currentColumnOrder.findIndex((key) => String(key) === over.id)\n\n      if (oldIndex === -1 || newIndex === -1) return\n\n      const newOrder = arrayMove(currentColumnOrder, oldIndex, newIndex)\n\n      if (onColumnReorder) {\n        onColumnReorder(newOrder)\n      } else {\n        setInternalColumnOrder(newOrder)\n      }\n    },\n    [currentColumnOrder, onColumnReorder]\n  )\n\n  // 로우 드래그 완료 핸들러\n  const handleRowDragEnd = React.useCallback(\n    (event: DragEndEvent) => {\n      const { active, over } = event\n      if (!over || active.id === over.id) return\n\n      // row- 접두사 제거 후 비교\n      const activeId = String(active.id).replace(/^row-/, \"\")\n      const overId = String(over.id).replace(/^row-/, \"\")\n\n      const oldIndex = data.findIndex((row) => String(row.id) === activeId)\n      const newIndex = data.findIndex((row) => String(row.id) === overId)\n\n      if (oldIndex === -1 || newIndex === -1) return\n\n      const newData = arrayMove(data, oldIndex, newIndex)\n      onRowReorder?.(newData)\n    },\n    [data, onRowReorder]\n  )\n\n  // 통합 드래그 완료 핸들러\n  const handleDragEnd = React.useCallback(\n    (event: DragEndEvent) => {\n      const { active } = event\n      // row-로 시작하면 로우 드래그, 아니면 컬럼 드래그\n      if (String(active.id).startsWith(\"row-\")) {\n        handleRowDragEnd(event)\n      } else {\n        handleColumnDragEnd(event)\n      }\n    },\n    [handleColumnDragEnd, handleRowDragEnd]\n  )\n\n  const expandedRowIds = expandable?.expandedRowIds ?? internalExpandedIds\n  const setExpandedRowIds = expandable?.onExpandedChange ?? setInternalExpandedIds\n\n  const isAllSelected = data.length > 0 && selectedIds.length === data.length\n  const isIndeterminate = selectedIds.length > 0 && !isAllSelected\n\n  const handleSelectAll = () => {\n    if (isAllSelected) {\n      onSelectionChange?.([])\n    } else {\n      onSelectionChange?.(data.map((row) => row.id))\n    }\n  }\n\n  const handleSelectRow = (id: string | number) => {\n    if (selectedIds.includes(id)) {\n      onSelectionChange?.(selectedIds.filter((i) => i !== id))\n    } else {\n      onSelectionChange?.([...selectedIds, id])\n    }\n  }\n\n  const handleSort = (column: keyof T) => {\n    if (!onSortChange) return\n\n    if (sortState?.column === column) {\n      if (sortState.direction === \"asc\") {\n        onSortChange({ column, direction: \"desc\" })\n      } else if (sortState.direction === \"desc\") {\n        onSortChange({ column: null, direction: null })\n      } else {\n        onSortChange({ column, direction: \"asc\" })\n      }\n    } else {\n      onSortChange({ column, direction: \"asc\" })\n    }\n  }\n\n  const getSortDirection = (column: keyof T): SortDirection => {\n    return sortState?.column === column ? sortState.direction : null\n  }\n\n  const getAlignClass = (align?: \"left\" | \"center\" | \"right\") => {\n    switch (align) {\n      case \"center\":\n        return \"text-center\"\n      case \"right\":\n        return \"text-right\"\n      default:\n        return \"text-left\"\n    }\n  }\n\n  const startEditing = (rowId: string | number, columnKey: keyof T, currentValue: T[keyof T]) => {\n    setEditingCell({ rowId, columnKey })\n    setEditValue(currentValue)\n    editValueRef.current = currentValue\n  }\n\n  const completeEditing = (column: DataTableColumn<T>, row: T) => {\n    // stale closure 방지를 위해 ref에서 읽음\n    const currentValue = editValueRef.current\n    if (!editingCell || currentValue === null) {\n      setEditingCell(null)\n      setEditValue(null)\n      editValueRef.current = null\n      return\n    }\n\n    if (column.validate) {\n      const result = column.validate(currentValue, row)\n      if (result !== true) {\n        setEditingCell({ ...editingCell, error: result })\n        return\n      }\n    }\n\n    if (onCellChange) {\n      onCellChange(editingCell.rowId, editingCell.columnKey, currentValue)\n    }\n    setEditingCell(null)\n    setEditValue(null)\n    editValueRef.current = null\n  }\n\n  const cancelEditing = React.useCallback(() => {\n    setEditingCell(null)\n    setEditValue(null)\n    editValueRef.current = null\n  }, [])\n\n  React.useEffect(() => {\n    if (!editingCell) return\n\n    const handleClickOutside = (e: MouseEvent) => {\n      const target = e.target as Node\n      if (editingCellRef.current?.contains(target)) return\n      // Radix 포털 (Select 드롭다운) 내부 클릭은 무시해야 함\n      const radixPortal = (target as Element).closest?.(\"[data-radix-popper-content-wrapper]\")\n      if (radixPortal) return\n      cancelEditing()\n    }\n\n    document.addEventListener(\"mousedown\", handleClickOutside)\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside)\n  }, [editingCell, cancelEditing])\n\n  const isEditing = (rowId: string | number, columnKey: keyof T) => {\n    return editingCell?.rowId === rowId && editingCell?.columnKey === columnKey\n  }\n\n  const isRowExpandable = (row: T) => {\n    if (!expandable) return false\n    if (expandable.rowExpandable) return expandable.rowExpandable(row)\n    return true\n  }\n\n  const isRowExpanded = (rowId: string | number) => {\n    return expandedRowIds.includes(rowId)\n  }\n\n  const toggleRowExpanded = (rowId: string | number) => {\n    if (isRowExpanded(rowId)) {\n      setExpandedRowIds(expandedRowIds.filter((id) => id !== rowId))\n    } else {\n      setExpandedRowIds([...expandedRowIds, rowId])\n    }\n  }\n\n  const totalColumns = columns.length + (selectable ? 1 : 0) + (expandable ? 1 : 0) + (rowReorderable ? 1 : 0)\n\n  // 로우 그룹핑: rowSpan 계산 + 그룹 중간 행 Set\n  const { rowSpanMap, middleRowSet } = React.useMemo(() => {\n    if (!rowGrouping) return { rowSpanMap: null, middleRowSet: null }\n\n    const groupByKeys = Array.isArray(rowGrouping.groupBy)\n      ? rowGrouping.groupBy\n      : [rowGrouping.groupBy]\n    const mergeColumns = rowGrouping.mergeColumns ?? groupByKeys\n\n    // Map: rowIndex -> columnKey -> rowSpan (0이면 이 셀은 렌더링하지 않음)\n    const spanMap = new Map<number, Map<keyof T, number>>()\n    // 그룹 중간에 있는 행들 (border-b 숨김)\n    const middleRows = new Set<number>()\n\n    // 각 병합 컬럼에 대해 rowSpan 계산\n    for (const colKey of mergeColumns) {\n      let i = 0\n      while (i < data.length) {\n        // 현재 행의 그룹 키 값들\n        const currentGroupValues = groupByKeys.map((k) => data[i][k])\n        const currentColValue = data[i][colKey]\n        let spanCount = 1\n\n        // 같은 그룹 값을 가진 연속된 행 수 계산\n        for (let j = i + 1; j < data.length; j++) {\n          const nextGroupValues = groupByKeys.map((k) => data[j][k])\n          const nextColValue = data[j][colKey]\n\n          // 그룹 키와 컬럼 값이 모두 같아야 병합\n          const sameGroup = currentGroupValues.every((v, idx) => v === nextGroupValues[idx])\n          const sameValue = currentColValue === nextColValue\n\n          if (sameGroup && sameValue) {\n            spanCount++\n          } else {\n            break\n          }\n        }\n\n        // 첫 번째 행에 rowSpan 설정\n        if (!spanMap.has(i)) {\n          spanMap.set(i, new Map())\n        }\n        spanMap.get(i)!.set(colKey, spanCount)\n\n        // 병합된 후속 행들은 rowSpan 0 (렌더링 안 함)\n        // + 그룹 중간 행 기록 (마지막 행 제외)\n        for (let k = i; k < i + spanCount - 1; k++) {\n          middleRows.add(k)\n        }\n        for (let k = i + 1; k < i + spanCount; k++) {\n          if (!spanMap.has(k)) {\n            spanMap.set(k, new Map())\n          }\n          spanMap.get(k)!.set(colKey, 0)\n        }\n\n        i += spanCount\n      }\n    }\n\n    return { rowSpanMap: spanMap, middleRowSet: middleRows }\n  }, [data, rowGrouping])\n\n  // 특정 셀의 rowSpan 가져오기\n  const getRowSpan = (rowIndex: number, columnKey: keyof T): number | undefined => {\n    if (!rowSpanMap) return undefined\n    const rowMap = rowSpanMap.get(rowIndex)\n    if (!rowMap) return undefined\n    const span = rowMap.get(columnKey)\n    return span\n  }\n\n  // 그룹 셀이 속한 행 범위 내에 호버된 행이 있는지 확인\n  const isGroupCellHovered = (rowIndex: number, rowSpan: number): boolean => {\n    if (hoveredRowIndex === null) return false\n    return hoveredRowIndex >= rowIndex && hoveredRowIndex < rowIndex + rowSpan\n  }\n\n  // 그룹 셀이 속한 행 범위 내에 선택된 행이 있는지 확인\n  const isGroupCellSelected = (rowIndex: number, rowSpan: number): boolean => {\n    for (let i = rowIndex; i < rowIndex + rowSpan; i++) {\n      if (i < data.length && selectedIds.includes(data[i].id)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  // 체크박스/확장/드래그 핸들 컬럼 너비 상수\n  const CHECKBOX_WIDTH = 40 // w-10 = 40px\n  const EXPAND_WIDTH = 40 // w-10 = 40px\n  const DRAG_HANDLE_WIDTH = 32 // w-8 = 32px\n\n  // Sticky 컬럼 위치 계산\n  const getStickyStyles = React.useMemo(() => {\n    // 컬럼 너비 추출 헬퍼 (width 우선, 없으면 minWidth)\n    const getColWidth = (col: DataTableColumn<T>): number => {\n      const w = col.width ?? col.minWidth\n      if (typeof w === \"number\") return w\n      const parsed = parseInt(String(w), 10)\n      return Number.isFinite(parsed) ? parsed : 150\n    }\n\n    const leftColumns = columns.filter((col) => col.sticky === \"left\")\n    const rightColumns = columns.filter((col) => col.sticky === \"right\")\n\n    // 왼쪽 고정 컬럼 위치 계산 (드래그 핸들, 체크박스, 확장 아이콘 컬럼 고려)\n    const dragHandleWidth = rowReorderable ? DRAG_HANDLE_WIDTH : 0\n    const checkboxWidth = selectable ? CHECKBOX_WIDTH : 0\n    const expandWidth = expandable ? EXPAND_WIDTH : 0\n    const baseLeftOffset = dragHandleWidth + checkboxWidth + expandWidth\n\n    const leftPositions = new Map<keyof T, number>()\n    let currentLeft = baseLeftOffset\n    for (const col of leftColumns) {\n      leftPositions.set(col.accessorKey, currentLeft)\n      currentLeft += getColWidth(col)\n    }\n\n    // 오른쪽 고정 컬럼 위치 계산 (역순)\n    const rightPositions = new Map<keyof T, number>()\n    let currentRight = 0\n    for (let i = rightColumns.length - 1; i >= 0; i--) {\n      const col = rightColumns[i]\n      rightPositions.set(col.accessorKey, currentRight)\n      currentRight += getColWidth(col)\n    }\n\n    // 마지막 왼쪽/첫 번째 오른쪽 고정 컬럼 (그림자용)\n    const lastLeftSticky = leftColumns.length > 0 ? leftColumns[leftColumns.length - 1].accessorKey : null\n    const firstRightSticky = rightColumns.length > 0 ? rightColumns[0].accessorKey : null\n\n    return (column: DataTableColumn<T>, isHeader: boolean, isSelected?: boolean, groupCellSelected?: boolean) => {\n      if (!column.sticky) return { style: {}, className: \"\" }\n\n      const isLastLeft = column.accessorKey === lastLeftSticky\n      const isFirstRight = column.accessorKey === firstRightSticky\n\n      // 컬럼 너비 (px 단위 문자열로 변환) - sticky는 고정 너비 필요\n      const colWidth = getColWidth(column)\n      const widthPx = `${colWidth}px`\n\n      const baseStyles: React.CSSProperties = {\n        position: \"sticky\",\n        zIndex: isHeader ? 20 : 10,\n        width: widthPx,\n        minWidth: widthPx,\n        maxWidth: widthPx,\n      }\n\n      // 그룹 셀 선택 상태가 있으면 우선 적용\n      const effectiveSelected = groupCellSelected ?? isSelected\n\n      if (column.sticky === \"left\") {\n        const leftPos = leftPositions.get(column.accessorKey) ?? 0\n        return {\n          style: {\n            ...baseStyles,\n            left: `${leftPos}px`,\n          },\n          // 헤더: hover 없음, 바디: 행 단위 hover (group-hover), 스티키는 다른 배경색\n          className: cn(\n            \"transition-colors\",\n            isHeader\n              ? \"bg-[#eaedf1] dark:bg-slate-800\"\n              : effectiveSelected\n                ? \"bg-blue-50 dark:bg-blue-900\"\n                : \"bg-slate-100 dark:bg-slate-800\",\n            isLastLeft && \"shadow-[2px_0_4px_rgba(0,0,0,0.08)]\"\n          ),\n        }\n      }\n\n      const rightPos = rightPositions.get(column.accessorKey) ?? 0\n      return {\n        style: {\n          ...baseStyles,\n          right: `${rightPos}px`,\n        },\n        className: cn(\n          \"transition-colors\",\n          isHeader\n            ? \"bg-[#eaedf1] dark:bg-slate-800\"\n            : effectiveSelected\n              ? \"bg-blue-50 dark:bg-blue-900\"\n              : \"bg-slate-100 dark:bg-slate-800\",\n          isFirstRight && \"shadow-[-2px_0_4px_rgba(0,0,0,0.08)]\"\n        ),\n      }\n    }\n  }, [columns, selectable, expandable])\n\n  // 체크박스/확장 컬럼도 sticky로 만들기 (왼쪽 고정 컬럼이 있을 때)\n  const hasLeftStickyColumns = columns.some((col) => col.sticky === \"left\")\n\n  // 컬럼 너비 가져오기 (제어/비제어 컴포넌트 통합)\n  const getColumnWidth = React.useCallback(\n    (column: DataTableColumn<T>): number | undefined => {\n      const key = String(column.accessorKey)\n      // 제어 컴포넌트\n      if (columnWidths && key in columnWidths) {\n        return columnWidths[key]\n      }\n      // 비제어 컴포넌트\n      if (key in internalColumnWidths) {\n        return internalColumnWidths[key]\n      }\n      // 초기값: column.width 또는 undefined\n      if (column.width) {\n        return typeof column.width === \"number\" ? column.width : parseInt(column.width, 10)\n      }\n      return undefined\n    },\n    [columnWidths, internalColumnWidths]\n  )\n\n  // 리사이즈 핸들러\n  const handleResizeStart = React.useCallback(\n    (e: React.MouseEvent, column: DataTableColumn<T>) => {\n      e.preventDefault()\n      e.stopPropagation()\n      setResizingColumn(column.accessorKey)\n      resizeStartX.current = e.clientX\n      const currentWidth = getColumnWidth(column) ?? 150\n      resizeStartWidth.current = currentWidth\n    },\n    [getColumnWidth]\n  )\n\n  const handleResizeMove = React.useCallback(\n    (e: MouseEvent) => {\n      if (!resizingColumn) return\n      const delta = e.clientX - resizeStartX.current\n      const newWidth = Math.max(50, resizeStartWidth.current + delta) // 최소 50px\n      const key = String(resizingColumn)\n\n      if (onColumnResize) {\n        onColumnResize(resizingColumn, newWidth)\n      } else {\n        setInternalColumnWidths((prev) => ({ ...prev, [key]: newWidth }))\n      }\n    },\n    [resizingColumn, onColumnResize]\n  )\n\n  const handleResizeEnd = React.useCallback(() => {\n    setResizingColumn(null)\n  }, [])\n\n  // 전역 마우스 이벤트 등록 (리사이징 중)\n  React.useEffect(() => {\n    if (!resizingColumn) return\n\n    document.addEventListener(\"mousemove\", handleResizeMove)\n    document.addEventListener(\"mouseup\", handleResizeEnd)\n    // 드래그 중 텍스트 선택 방지\n    document.body.style.userSelect = \"none\"\n    document.body.style.cursor = \"col-resize\"\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleResizeMove)\n      document.removeEventListener(\"mouseup\", handleResizeEnd)\n      document.body.style.userSelect = \"\"\n      document.body.style.cursor = \"\"\n    }\n  }, [resizingColumn, handleResizeMove, handleResizeEnd])\n\n  // 컬럼 헤더 렌더링 함수\n  const renderColumnHeader = (column: DataTableColumn<T>) => {\n    const stickyData = getStickyStyles(column, true)\n    const toPx = (v: string | number) => typeof v === \"number\" ? `${v}px` : v\n    const baseStyle: React.CSSProperties = {}\n    if (!column.sticky) {\n      const resizedWidth = resizable ? getColumnWidth(column) : undefined\n      if (resizedWidth !== undefined) {\n        baseStyle.width = `${resizedWidth}px`\n        baseStyle.minWidth = `${resizedWidth}px`\n      } else {\n        if (column.width) baseStyle.width = toPx(column.width)\n        if (column.minWidth) baseStyle.minWidth = toPx(column.minWidth)\n      }\n    }\n    const style = { ...baseStyle, ...stickyData.style }\n\n    // 리사이즈 핸들 컴포넌트\n    const resizeHandle = resizable && (\n      <div\n        className={cn(\n          \"absolute top-0 h-full w-[9px] cursor-col-resize opacity-0 hover:opacity-100 transition-opacity z-30\",\n          resizingColumn === column.accessorKey && \"opacity-100\"\n        )}\n        style={{\n          right: \"-4px\",\n          background: \"linear-gradient(to right, transparent, rgba(148,163,184,0.5) 50%, transparent)\"\n        }}\n        onMouseDown={(e) => handleResizeStart(e, column)}\n        onPointerDown={(e) => e.stopPropagation()}\n        onClick={(e) => e.stopPropagation()}\n      />\n    )\n\n    // 드래그 가능 여부 (sticky 컬럼은 드래그 불가)\n    const isDraggable = columnReorderable && !column.sticky && !column.sortable\n\n    if (isDraggable) {\n      return (\n        <SortableHeaderCell\n          key={String(column.accessorKey)}\n          id={String(column.accessorKey)}\n          style={style}\n          className={cn(getAlignClass(column.align), stickyData.className, resizable && \"relative overflow-visible\")}\n        >\n          {column.header}\n          {resizeHandle}\n        </SortableHeaderCell>\n      )\n    }\n\n    if (column.sortable) {\n      return (\n        <TableSortableHead\n          key={String(column.accessorKey)}\n          sortDirection={getSortDirection(column.accessorKey)}\n          onSort={() => handleSort(column.accessorKey)}\n          style={style}\n          className={cn(getAlignClass(column.align), stickyData.className, resizable && \"relative overflow-visible\")}\n        >\n          {column.header}\n          {resizeHandle}\n        </TableSortableHead>\n      )\n    }\n\n    return (\n      <TableHead\n        key={String(column.accessorKey)}\n        style={style}\n        className={cn(getAlignClass(column.align), stickyData.className, resizable && \"relative overflow-visible\")}\n      >\n        {column.header}\n        {resizeHandle}\n      </TableHead>\n    )\n  }\n\n  const columnsToRender = columnReorderable ? orderedColumns : columns\n  const columnIds = columnsToRender.filter(col => !col.sticky).map(col => String(col.accessorKey))\n  const rowIds = data.map(row => `row-${row.id}`)\n\n  // 드래그 핸들 헤더 sticky left 위치 계산\n  const getDragHandleHeaderLeftOffset = () => 0\n  // 체크박스 헤더 sticky left 위치 계산\n  const getCheckboxHeaderLeftOffset = () => rowReorderable ? DRAG_HANDLE_WIDTH : 0\n  // 확장 버튼 헤더 sticky left 위치 계산\n  const getExpandHeaderLeftOffset = () => {\n    let offset = 0\n    if (rowReorderable) offset += DRAG_HANDLE_WIDTH\n    if (selectable) offset += CHECKBOX_WIDTH\n    return offset\n  }\n\n  // 헤더 그룹의 colSpan 계산\n  const getHeaderGroupColSpan = React.useCallback(\n    (group: HeaderGroup<T>): number => {\n      // 실제 렌더링되는 컬럼 순서에서 해당 그룹에 속하는 컬럼 수 계산\n      return columnsToRender.filter((col) =>\n        group.columns.includes(col.accessorKey)\n      ).length\n    },\n    [columnsToRender]\n  )\n\n  // 헤더 그룹에 속하는 컬럼들 (Set)\n  const groupedColumnsSet = React.useMemo(() => {\n    if (!headerGroups) return new Set<keyof T>()\n    return new Set(headerGroups.flatMap((g) => g.columns))\n  }, [headerGroups])\n\n  const tableContent = (\n    <Table className={className} maxHeight={maxHeight}>\n      <TableHeader>\n        {/* 헤더 그룹 행 (headerGroups가 있을 때만 렌더링) */}\n        {headerGroups && headerGroups.length > 0 && (\n          <TableRow>\n            {/* 드래그 핸들, 체크박스, 확장 버튼 컬럼용 빈 셀 */}\n            {rowReorderable && (\n              <TableHead\n                className=\"!p-0 bg-[#eaedf1] dark:bg-slate-800 border-b-0\"\n                rowSpan={2}\n                style={{\n                  width: `${DRAG_HANDLE_WIDTH}px`,\n                  minWidth: `${DRAG_HANDLE_WIDTH}px`,\n                  ...(hasLeftStickyColumns && { position: \"sticky\", left: 0, zIndex: 20 }),\n                }}\n              />\n            )}\n            {selectable && (\n              <TableHead\n                className=\"!p-0 bg-[#eaedf1] dark:bg-slate-800 border-b-0\"\n                rowSpan={2}\n                style={{\n                  width: `${CHECKBOX_WIDTH}px`,\n                  minWidth: `${CHECKBOX_WIDTH}px`,\n                  ...(hasLeftStickyColumns && { position: \"sticky\", left: rowReorderable ? DRAG_HANDLE_WIDTH : 0, zIndex: 20 }),\n                }}\n              >\n                <div className=\"flex items-center justify-center h-9\">\n                  <Checkbox\n                    checked={isAllSelected}\n                    indeterminate={isIndeterminate}\n                    onCheckedChange={handleSelectAll}\n                    aria-label=\"전체 선택\"\n                  />\n                </div>\n              </TableHead>\n            )}\n            {expandable && (\n              <TableHead\n                className=\"bg-[#eaedf1] dark:bg-slate-800 border-b-0\"\n                rowSpan={2}\n                style={{\n                  width: `${EXPAND_WIDTH}px`,\n                  minWidth: `${EXPAND_WIDTH}px`,\n                  ...(hasLeftStickyColumns && { position: \"sticky\", left: getExpandHeaderLeftOffset(), zIndex: 20 }),\n                }}\n              />\n            )}\n\n            {/* 헤더 그룹과 독립 컬럼들 렌더링 */}\n            {(() => {\n              const groupedColumns = new Set(headerGroups.flatMap((g) => g.columns))\n              const elements: React.ReactNode[] = []\n              let i = 0\n\n              while (i < columnsToRender.length) {\n                const col = columnsToRender[i]\n\n                // 이 컬럼이 어떤 그룹에 속하는지 확인\n                const group = headerGroups.find((g) =>\n                  g.columns.includes(col.accessorKey)\n                )\n\n                if (group) {\n                  // 그룹의 첫 번째 컬럼인 경우에만 그룹 헤더 렌더링\n                  const groupFirstCol = columnsToRender.find((c) =>\n                    group.columns.includes(c.accessorKey)\n                  )\n                  if (groupFirstCol?.accessorKey === col.accessorKey) {\n                    const colSpan = getHeaderGroupColSpan(group)\n                    elements.push(\n                      <TableHead\n                        key={`group-${String(group.columns[0])}`}\n                        colSpan={colSpan}\n                        className={cn(\n                          \"text-center font-medium bg-[#eaedf1] dark:bg-slate-800\",\n                          group.align === \"left\" && \"text-left\",\n                          group.align === \"right\" && \"text-right\"\n                        )}\n                      >\n                        {group.header}\n                      </TableHead>\n                    )\n                  }\n                } else if (!groupedColumns.has(col.accessorKey)) {\n                  // 독립 컬럼 (그룹에 속하지 않음) - rowSpan=2\n                  const stickyData = getStickyStyles(col, true)\n                  elements.push(\n                    <TableHead\n                      key={`standalone-${String(col.accessorKey)}`}\n                      rowSpan={2}\n                      className={cn(\n                        getAlignClass(col.align),\n                        \"bg-[#eaedf1] dark:bg-slate-800 border-b-0\",\n                        stickyData.className\n                      )}\n                      style={stickyData.style}\n                    >\n                      {col.header}\n                    </TableHead>\n                  )\n                }\n                i++\n              }\n              return elements\n            })()}\n          </TableRow>\n        )}\n\n        {/* 메인 헤더 행 */}\n        <TableRow>\n          {/* headerGroups가 있으면 이 컬럼들은 위 행에서 rowSpan=2로 렌더링됨 */}\n          {!headerGroups && rowReorderable && (\n            <TableHead\n              className=\"!p-0 bg-[#eaedf1] dark:bg-slate-800\"\n              style={hasLeftStickyColumns ? {\n                position: \"sticky\",\n                left: getDragHandleHeaderLeftOffset(),\n                zIndex: 20,\n                width: `${DRAG_HANDLE_WIDTH}px`,\n                minWidth: `${DRAG_HANDLE_WIDTH}px`,\n                maxWidth: `${DRAG_HANDLE_WIDTH}px`,\n              } : {\n                width: `${DRAG_HANDLE_WIDTH}px`,\n                minWidth: `${DRAG_HANDLE_WIDTH}px`,\n                maxWidth: `${DRAG_HANDLE_WIDTH}px`,\n              }}\n              aria-label=\"순서 변경\"\n            >\n              <span className=\"sr-only\">순서 변경</span>\n            </TableHead>\n          )}\n\n          {!headerGroups && selectable && (\n            <TableHead\n              className=\"!p-0 bg-[#eaedf1] dark:bg-slate-800\"\n              style={hasLeftStickyColumns ? {\n                position: \"sticky\",\n                left: getCheckboxHeaderLeftOffset(),\n                zIndex: 20,\n                width: `${CHECKBOX_WIDTH}px`,\n                minWidth: `${CHECKBOX_WIDTH}px`,\n                maxWidth: `${CHECKBOX_WIDTH}px`,\n              } : {\n                width: `${CHECKBOX_WIDTH}px`,\n                minWidth: `${CHECKBOX_WIDTH}px`,\n                maxWidth: `${CHECKBOX_WIDTH}px`,\n              }}\n            >\n              <div className=\"flex items-center justify-center h-9\">\n                <Checkbox\n                  checked={isAllSelected}\n                  indeterminate={isIndeterminate}\n                  onCheckedChange={handleSelectAll}\n                  aria-label=\"전체 선택\"\n                />\n              </div>\n            </TableHead>\n          )}\n\n          {!headerGroups && expandable && (\n            <TableHead\n              className=\"bg-[#eaedf1] dark:bg-slate-800\"\n              style={hasLeftStickyColumns ? {\n                position: \"sticky\",\n                left: getExpandHeaderLeftOffset(),\n                zIndex: 20,\n                width: `${EXPAND_WIDTH}px`,\n                minWidth: `${EXPAND_WIDTH}px`,\n                maxWidth: `${EXPAND_WIDTH}px`,\n              } : {\n                width: `${EXPAND_WIDTH}px`,\n                minWidth: `${EXPAND_WIDTH}px`,\n                maxWidth: `${EXPAND_WIDTH}px`,\n              }}\n              aria-label=\"확장\"\n            >\n              <span className=\"sr-only\">확장</span>\n            </TableHead>\n          )}\n\n          {/* headerGroups가 있으면 그룹에 속한 컬럼만 렌더링 (독립 컬럼은 위 행에서 rowSpan=2) */}\n          {headerGroups ? (\n            columnReorderable ? (\n              <SortableContext items={columnIds} strategy={horizontalListSortingStrategy}>\n                {columnsToRender\n                  .filter((col) => groupedColumnsSet.has(col.accessorKey))\n                  .map(renderColumnHeader)}\n              </SortableContext>\n            ) : (\n              columnsToRender\n                .filter((col) => groupedColumnsSet.has(col.accessorKey))\n                .map(renderColumnHeader)\n            )\n          ) : (\n            columnReorderable ? (\n              <SortableContext items={columnIds} strategy={horizontalListSortingStrategy}>\n                {columnsToRender.map(renderColumnHeader)}\n              </SortableContext>\n            ) : (\n              columnsToRender.map(renderColumnHeader)\n            )\n          )}\n        </TableRow>\n      </TableHeader>\n\n      <TableBody>\n        {loading ? (\n          <TableRow className=\"hover:bg-white dark:hover:bg-slate-900\">\n            <TableCell\n              colSpan={totalColumns}\n              className={cn(\n                \"text-center\",\n                loadingContent || loadingMode !== \"skeleton\" ? \"h-80\" : \"p-0 align-top\"\n              )}\n            >\n              {loadingContent ?? (\n                loadingMode === \"skeleton\" ? (\n                  // 스켈레톤 모드: 컬럼 기반 자동 생성\n                  (() => {\n                    const ROW_HEIGHT = 41\n                    // maxHeight가 있으면 그걸 기준으로, 없으면 기본 로딩 영역 높이 사용\n                    const containerHeight = typeof maxHeight === \"number\"\n                      ? maxHeight\n                      : typeof maxHeight === \"string\"\n                        ? parseInt(maxHeight, 10) || 320\n                        : 320\n                    const skeletonRowCount = Math.max(1, Math.floor(containerHeight / ROW_HEIGHT))\n\n                    return (\n                      <table className=\"w-full\">\n                        <tbody>\n                          {Array.from({ length: skeletonRowCount }).map((_, rowIdx) => (\n                            <tr\n                              key={rowIdx}\n                              className=\"border-b border-slate-200 dark:border-slate-700 last:border-b-0\"\n                            >\n                              {/* 드래그 핸들 */}\n                              {rowReorderable && (\n                                <td className=\"w-8 p-2\">\n                                  <Skeleton width={16} height={16} />\n                                </td>\n                              )}\n                              {/* 체크박스 */}\n                              {selectable && (\n                                <td className=\"w-10 p-2\">\n                                  <Skeleton width={18} height={18} />\n                                </td>\n                              )}\n                              {/* 확장 버튼 */}\n                              {expandable && (\n                                <td className=\"w-10 p-2\">\n                                  <Skeleton width={18} height={18} />\n                                </td>\n                              )}\n                              {/* 컬럼별 스켈레톤 */}\n                              {columnsToRender.map((col) => {\n                                const colWidth = col.width ?? col.minWidth\n                                const skeletonWidth = typeof colWidth === \"number\"\n                                  ? Math.min(colWidth * 0.6, 150)\n                                  : 100\n                                return (\n                                  <td key={String(col.accessorKey)} className=\"p-2\">\n                                    <Skeleton height={16} width={skeletonWidth} />\n                                  </td>\n                                )\n                              })}\n                            </tr>\n                          ))}\n                        </tbody>\n                      </table>\n                    )\n                  })()\n                ) : (\n                  // 스플래시 모드 (기본)\n                  <div className=\"flex items-center justify-center h-full\">\n                    <SplashScreen size=\"lg\" />\n                  </div>\n                )\n              )}\n            </TableCell>\n          </TableRow>\n        ) : data.length === 0 ? (\n          <TableRow className=\"hover:bg-white dark:hover:bg-slate-900\">\n            <TableCell\n              colSpan={totalColumns}\n              className=\"h-24 text-center text-slate-500\"\n            >\n              {emptyMessage}\n            </TableCell>\n          </TableRow>\n        ) : rowReorderable ? (\n          <SortableContext items={rowIds} strategy={verticalListSortingStrategy}>\n            {data.map((row, rowIndex) => {\n              const isSelected = selectedIds.includes(row.id)\n              const canExpand = isRowExpandable(row)\n              const isExpanded = isRowExpanded(row.id)\n              const rowSortableId = `row-${row.id}`\n              // 로우 내부 셀들 렌더링 함수\n              const renderRowCells = (dragHandleProps?: DragHandleProps) => (\n                <>\n                  <DragHandleCell\n                    isSelected={isSelected}\n                    hasLeftStickyColumns={hasLeftStickyColumns}\n                    dragHandleProps={dragHandleProps}\n                  />\n\n                  {selectable && (\n                    <TableCell\n                      onClick={(e) => e.stopPropagation()}\n                      className={cn(\n                        \"!p-0\",\n                        hasLeftStickyColumns && (isSelected ? \"transition-colors bg-blue-50 dark:bg-blue-900\" : \"transition-colors bg-slate-100 dark:bg-slate-800\")\n                      )}\n                      style={hasLeftStickyColumns ? {\n                        position: \"sticky\",\n                        left: getCheckboxHeaderLeftOffset(),\n                        zIndex: 10,\n                        width: `${CHECKBOX_WIDTH}px`,\n                        minWidth: `${CHECKBOX_WIDTH}px`,\n                        maxWidth: `${CHECKBOX_WIDTH}px`,\n                      } : {\n                        width: `${CHECKBOX_WIDTH}px`,\n                        minWidth: `${CHECKBOX_WIDTH}px`,\n                        maxWidth: `${CHECKBOX_WIDTH}px`,\n                      }}\n                    >\n                      <div className=\"flex items-center justify-center h-9\">\n                        <Checkbox\n                          checked={isSelected}\n                          onCheckedChange={() => handleSelectRow(row.id)}\n                          aria-label={`행 ${row.id} 선택`}\n                        />\n                      </div>\n                    </TableCell>\n                  )}\n\n                  {expandable && (\n                    <TableCell\n                      className={cn(\n                        \"p-0\",\n                        hasLeftStickyColumns && (isSelected ? \"transition-colors bg-blue-50 dark:bg-blue-900\" : \"transition-colors bg-slate-100 dark:bg-slate-800\")\n                      )}\n                      style={hasLeftStickyColumns ? {\n                        position: \"sticky\",\n                        left: getExpandHeaderLeftOffset(),\n                        zIndex: 10,\n                        width: `${EXPAND_WIDTH}px`,\n                        minWidth: `${EXPAND_WIDTH}px`,\n                        maxWidth: `${EXPAND_WIDTH}px`,\n                      } : {\n                        width: `${EXPAND_WIDTH}px`,\n                        minWidth: `${EXPAND_WIDTH}px`,\n                        maxWidth: `${EXPAND_WIDTH}px`,\n                      }}\n                      onClick={(e) => e.stopPropagation()}\n                    >\n                      {canExpand && (\n                        <button\n                          type=\"button\"\n                          onClick={() => toggleRowExpanded(row.id)}\n                          className=\"flex h-9 w-10 items-center justify-center text-slate-400 hover:text-slate-600 dark:hover:text-slate-200 transition-colors\"\n                          aria-label={isExpanded ? \"행 접기\" : \"행 펼치기\"}\n                          aria-expanded={isExpanded}\n                        >\n                          {isExpanded ? (\n                            <DownIcon size={24} />\n                          ) : (\n                            <RightIcon size={24} />\n                          )}\n                        </button>\n                      )}\n                    </TableCell>\n                  )}\n\n                  {columnsToRender.map((column) => {\n                    // 로우 그룹핑: rowSpan 확인\n                    const rowSpan = getRowSpan(rowIndex, column.accessorKey)\n                    // rowSpan이 0이면 이 셀은 이전 행에서 병합되었으므로 렌더링하지 않음\n                    if (rowSpan === 0) return null\n\n                    const value = row[column.accessorKey]\n                    const cellIsEditing = isEditing(row.id, column.accessorKey)\n                    // rowSpan이 있는 셀은 세로 중앙 정렬\n                    const hasRowSpan = rowSpan !== undefined && rowSpan > 1\n                    // 그룹 셀의 hover/selected 상태 (범위 내 행 중 하나라도 hover/selected면 true)\n                    const groupCellHovered = hasRowSpan && isGroupCellHovered(rowIndex, rowSpan)\n                    const groupCellSelected = hasRowSpan && isGroupCellSelected(rowIndex, rowSpan)\n                    // sticky 스타일 (그룹 셀 선택 상태 전달)\n                    const stickyData = getStickyStyles(column, false, isSelected, hasRowSpan ? groupCellSelected : undefined)\n\n                    const toPx = (v: string | number) => typeof v === \"number\" ? `${v}px` : v\n                    const bodyCellStyle: React.CSSProperties = {}\n                    if (!column.sticky) {\n                      const resizedWidth = resizable ? getColumnWidth(column) : undefined\n                      if (resizedWidth !== undefined) {\n                        bodyCellStyle.width = `${resizedWidth}px`\n                        bodyCellStyle.minWidth = `${resizedWidth}px`\n                      } else {\n                        if (column.width) bodyCellStyle.width = toPx(column.width)\n                        if (column.minWidth) bodyCellStyle.minWidth = toPx(column.minWidth)\n                      }\n                    }\n                    const cellStyle = { ...bodyCellStyle, ...stickyData.style }\n\n                    if (cellIsEditing && column.editable) {\n                      const EditComponent = column.editComponent || DefaultEditComponent\n                      return (\n                        <TableCell\n                          ref={editingCellRef}\n                          key={String(column.accessorKey)}\n                          className={cn(getAlignClass(column.align), \"p-1 overflow-hidden\", stickyData.className)}\n                          style={cellStyle}\n                          onClick={(e) => e.stopPropagation()}\n                          rowSpan={hasRowSpan ? rowSpan : undefined}\n                        >\n                          <EditComponent\n                            value={editValue as T[keyof T]}\n                            onChange={(newValue) => {\n                              setEditValue(newValue)\n                              editValueRef.current = newValue\n                              if (editingCell?.error) {\n                                setEditingCell({ ...editingCell, error: undefined })\n                              }\n                            }}\n                            onComplete={() => completeEditing(column, row)}\n                            onCancel={cancelEditing}\n                            row={row}\n                            error={editingCell?.error}\n                          />\n                        </TableCell>\n                      )\n                    }\n\n                    const content = column.cell ? column.cell(value, row) : String(value ?? \"\")\n\n                    if (column.editable && onCellChange) {\n                      return (\n                        <TableCell\n                          key={String(column.accessorKey)}\n                          className={cn(\n                            getAlignClass(column.align),\n                            \"group/edit cursor-text hover:bg-blue-100 dark:hover:bg-blue-800\",\n                            hasRowSpan && \"align-middle\",\n                            stickyData.className\n                          )}\n                          style={cellStyle}\n                          onClick={(e) => {\n                            e.stopPropagation()\n                            setTimeout(() => startEditing(row.id, column.accessorKey, value), 0)\n                          }}\n                          rowSpan={hasRowSpan ? rowSpan : undefined}\n                        >\n                          <span className=\"flex items-center gap-1\">\n                            <span className=\"flex-1\">{content}</span>\n                            <WriteIcon\n                              size={14}\n                              className=\"flex-shrink-0 opacity-0 group-hover/edit:opacity-100 transition-opacity text-blue-500 dark:text-blue-300\"\n                            />\n                          </span>\n                        </TableCell>\n                      )\n                    }\n\n                    // 그룹 셀이 테이블 마지막 행까지 걸쳐있으면 border-b 제외\n                    const isGroupSpanToEnd = hasRowSpan && (rowIndex + rowSpan >= data.length)\n\n                    return (\n                      <TableCell\n                        key={String(column.accessorKey)}\n                        className={cn(\n                          getAlignClass(column.align),\n                          hasRowSpan && \"align-middle transition-colors\",\n                          hasRowSpan && !isGroupSpanToEnd && \"border-b border-slate-200 dark:border-slate-700\",\n                          // 그룹 셀 hover/selected 스타일\n                          hasRowSpan && groupCellSelected && \"bg-blue-50 dark:bg-blue-900\",\n                          hasRowSpan && !groupCellSelected && groupCellHovered && \"bg-slate-100 dark:bg-slate-800\",\n                          stickyData.className\n                        )}\n                        style={cellStyle}\n                        rowSpan={hasRowSpan ? rowSpan : undefined}\n                      >\n                        {content}\n                      </TableCell>\n                    )\n                  })}\n                </>\n              )\n\n              return (\n                <React.Fragment key={row.id}>\n                  <SortableRow\n                    id={rowSortableId}\n                    isSelected={isSelected}\n                    className={cn(onRowClick && \"cursor-pointer\", rowClassName?.(row))}\n                    onClick={() => onRowClick?.(row)}\n                    onMouseEnter={rowGrouping ? () => setHoveredRowIndex(rowIndex) : undefined}\n                    onMouseLeave={rowGrouping ? () => setHoveredRowIndex(null) : undefined}\n                  >\n                    {(dragHandleProps) => renderRowCells(dragHandleProps)}\n                  </SortableRow>\n\n                  {expandable && isExpanded && (\n                    <TableRow className=\"bg-white dark:bg-slate-800/50 hover:bg-white dark:hover:bg-slate-800/50\">\n                      <TableCell\n                        colSpan={totalColumns}\n                        className=\"p-0\"\n                        style={{ position: \"relative\" }}\n                      >\n                        <div\n                          className=\"p-4 overflow-x-auto\"\n                          style={{\n                            position: \"sticky\",\n                            left: 0,\n                            width: \"100%\",\n                            maxWidth: \"100vw\",\n                          }}\n                        >\n                          {expandable.expandedRowRender(row)}\n                        </div>\n                      </TableCell>\n                    </TableRow>\n                  )}\n                </React.Fragment>\n              )\n            })}\n          </SortableContext>\n        ) : (\n          data.map((row, rowIndex) => {\n            const isSelected = selectedIds.includes(row.id)\n            const canExpand = isRowExpandable(row)\n            const isExpanded = isRowExpanded(row.id)\n            const rowSortableId = `row-${row.id}`\n\n            // 로우 내부 셀들 렌더링 함수\n            const renderRowCells = (dragHandleProps?: DragHandleProps) => (\n              <>\n                {rowReorderable && (\n                  <DragHandleCell\n                    isSelected={isSelected}\n                    hasLeftStickyColumns={hasLeftStickyColumns}\n                    dragHandleProps={dragHandleProps}\n                  />\n                )}\n\n                {selectable && (\n                  <TableCell\n                    onClick={(e) => e.stopPropagation()}\n                    className={cn(\n                      \"!p-0\",\n                      hasLeftStickyColumns && (\n                        isSelected\n                          ? \"transition-colors bg-blue-50 dark:bg-blue-900\"\n                          : \"transition-colors bg-slate-100 dark:bg-slate-800\"\n                      )\n                    )}\n                    style={hasLeftStickyColumns ? {\n                      position: \"sticky\",\n                      left: getCheckboxHeaderLeftOffset(),\n                      zIndex: 10,\n                      width: `${CHECKBOX_WIDTH}px`,\n                      minWidth: `${CHECKBOX_WIDTH}px`,\n                      maxWidth: `${CHECKBOX_WIDTH}px`,\n                    } : {\n                      width: `${CHECKBOX_WIDTH}px`,\n                      minWidth: `${CHECKBOX_WIDTH}px`,\n                      maxWidth: `${CHECKBOX_WIDTH}px`,\n                    }}\n                  >\n                    <div className=\"flex items-center justify-center h-9\">\n                      <Checkbox\n                        checked={isSelected}\n                        onCheckedChange={() => handleSelectRow(row.id)}\n                        aria-label={`행 ${row.id} 선택`}\n                      />\n                    </div>\n                  </TableCell>\n                )}\n\n                {expandable && (\n                  <TableCell\n                    className={cn(\n                      \"p-0\",\n                      hasLeftStickyColumns && (\n                        isSelected\n                          ? \"transition-colors bg-blue-50 dark:bg-blue-900\"\n                          : \"transition-colors bg-slate-100 dark:bg-slate-800\"\n                      )\n                    )}\n                    style={hasLeftStickyColumns ? {\n                      position: \"sticky\",\n                      left: getExpandHeaderLeftOffset(),\n                      zIndex: 10,\n                      width: `${EXPAND_WIDTH}px`,\n                      minWidth: `${EXPAND_WIDTH}px`,\n                      maxWidth: `${EXPAND_WIDTH}px`,\n                    } : {\n                      width: `${EXPAND_WIDTH}px`,\n                      minWidth: `${EXPAND_WIDTH}px`,\n                      maxWidth: `${EXPAND_WIDTH}px`,\n                    }}\n                    onClick={(e) => e.stopPropagation()}\n                  >\n                    {canExpand && (\n                      <button\n                        type=\"button\"\n                        onClick={() => toggleRowExpanded(row.id)}\n                        className=\"flex h-9 w-10 items-center justify-center text-slate-400 hover:text-slate-600 dark:hover:text-slate-200 transition-colors\"\n                        aria-label={isExpanded ? \"행 접기\" : \"행 펼치기\"}\n                        aria-expanded={isExpanded}\n                      >\n                        {isExpanded ? (\n                          <DownIcon size={24} />\n                        ) : (\n                          <RightIcon size={24} />\n                        )}\n                      </button>\n                    )}\n                  </TableCell>\n                )}\n\n                {columnsToRender.map((column) => {\n                  // 로우 그룹핑: rowSpan 확인\n                  const rowSpan = getRowSpan(rowIndex, column.accessorKey)\n                  // rowSpan이 0이면 이 셀은 이전 행에서 병합되었으므로 렌더링하지 않음\n                  if (rowSpan === 0) return null\n\n                  const value = row[column.accessorKey]\n                  const cellIsEditing = isEditing(row.id, column.accessorKey)\n                  // rowSpan이 있는 셀은 세로 중앙 정렬\n                  const hasRowSpan = rowSpan !== undefined && rowSpan > 1\n                  // 그룹 셀의 hover/selected 상태 (범위 내 행 중 하나라도 hover/selected면 true)\n                  const groupCellHovered = hasRowSpan && isGroupCellHovered(rowIndex, rowSpan)\n                  const groupCellSelected = hasRowSpan && isGroupCellSelected(rowIndex, rowSpan)\n                  // sticky 스타일 (그룹 셀 선택 상태 전달)\n                  const stickyData = getStickyStyles(column, false, isSelected, hasRowSpan ? groupCellSelected : undefined)\n\n                  // 바디 셀 너비 계산 (헤더와 동일한 로직)\n                  const toPx = (v: string | number) => typeof v === \"number\" ? `${v}px` : v\n                  const bodyCellStyle: React.CSSProperties = {}\n                  if (!column.sticky) {\n                    const resizedWidth = resizable ? getColumnWidth(column) : undefined\n                    if (resizedWidth !== undefined) {\n                      bodyCellStyle.width = `${resizedWidth}px`\n                      bodyCellStyle.minWidth = `${resizedWidth}px`\n                    } else {\n                      if (column.width) bodyCellStyle.width = toPx(column.width)\n                      if (column.minWidth) bodyCellStyle.minWidth = toPx(column.minWidth)\n                    }\n                  }\n                  const cellStyle = { ...bodyCellStyle, ...stickyData.style }\n\n                  if (cellIsEditing && column.editable) {\n                    const EditComponent = column.editComponent || DefaultEditComponent\n\n                    return (\n                      <TableCell\n                        ref={editingCellRef}\n                        key={String(column.accessorKey)}\n                        className={cn(getAlignClass(column.align), \"p-1 overflow-hidden\", stickyData.className)}\n                        style={cellStyle}\n                        onClick={(e) => e.stopPropagation()}\n                        rowSpan={hasRowSpan ? rowSpan : undefined}\n                      >\n                        <EditComponent\n                          value={editValue as T[keyof T]}\n                          onChange={(newValue) => {\n                            setEditValue(newValue)\n                            // stale closure 방지\n                            editValueRef.current = newValue\n                            if (editingCell?.error) {\n                              setEditingCell({ ...editingCell, error: undefined })\n                            }\n                          }}\n                          onComplete={() => completeEditing(column, row)}\n                          onCancel={cancelEditing}\n                          row={row}\n                          error={editingCell?.error}\n                        />\n                      </TableCell>\n                    )\n                  }\n\n                  const content = column.cell\n                    ? column.cell(value, row)\n                    : String(value ?? \"\")\n\n                  if (column.editable && onCellChange) {\n                    return (\n                      <TableCell\n                        key={String(column.accessorKey)}\n                        className={cn(\n                          getAlignClass(column.align),\n                          \"group/edit cursor-text hover:bg-blue-100 dark:hover:bg-blue-800\",\n                          hasRowSpan && \"align-middle\",\n                          stickyData.className\n                        )}\n                        style={cellStyle}\n                        onClick={(e) => {\n                          e.stopPropagation()\n                          // 이전 셀의 blur 처리가 먼저 완료되어야 함\n                          setTimeout(() => {\n                            startEditing(row.id, column.accessorKey, value)\n                          }, 0)\n                        }}\n                        rowSpan={hasRowSpan ? rowSpan : undefined}\n                      >\n                        <span className=\"flex items-center gap-1\">\n                          <span className=\"flex-1\">{content}</span>\n                          <WriteIcon\n                            size={20}\n                            className=\"flex-shrink-0 opacity-0 group-hover/edit:opacity-100 transition-opacity text-blue-500 dark:text-blue-300\"\n                          />\n                        </span>\n                      </TableCell>\n                    )\n                  }\n\n                  // 그룹 셀이 테이블 마지막 행까지 걸쳐있으면 border-b 제외\n                  const isGroupSpanToEnd = hasRowSpan && (rowIndex + rowSpan >= data.length)\n\n                  return (\n                    <TableCell\n                      key={String(column.accessorKey)}\n                      className={cn(\n                        getAlignClass(column.align),\n                        hasRowSpan && \"align-middle transition-colors\",\n                        hasRowSpan && !isGroupSpanToEnd && \"border-b border-slate-200 dark:border-slate-700\",\n                        // 그룹 셀 hover/selected 스타일\n                        hasRowSpan && groupCellSelected && \"bg-blue-50 dark:bg-blue-900\",\n                        hasRowSpan && !groupCellSelected && groupCellHovered && \"bg-slate-100 dark:bg-slate-800\",\n                        stickyData.className\n                      )}\n                      style={cellStyle}\n                      rowSpan={hasRowSpan ? rowSpan : undefined}\n                    >\n                      {content}\n                    </TableCell>\n                  )\n                })}\n              </>\n            )\n\n            return (\n              <React.Fragment key={row.id}>\n                {rowReorderable ? (\n                  <SortableRow\n                    id={rowSortableId}\n                    isSelected={isSelected}\n                    className={cn(onRowClick && \"cursor-pointer\", rowClassName?.(row))}\n                    onClick={() => onRowClick?.(row)}\n                    onMouseEnter={rowGrouping ? () => setHoveredRowIndex(rowIndex) : undefined}\n                    onMouseLeave={rowGrouping ? () => setHoveredRowIndex(null) : undefined}\n                  >\n                    {(dragHandleProps) => renderRowCells(dragHandleProps)}\n                  </SortableRow>\n                ) : (\n                  <TableRow\n                    data-state={isSelected ? \"selected\" : undefined}\n                    className={cn(\n                      onRowClick && \"cursor-pointer\",\n                      middleRowSet?.has(rowIndex) && \"border-b-0\",\n                      rowClassName?.(row)\n                    )}\n                    onClick={() => onRowClick?.(row)}\n                    onMouseEnter={rowGrouping ? () => setHoveredRowIndex(rowIndex) : undefined}\n                    onMouseLeave={rowGrouping ? () => setHoveredRowIndex(null) : undefined}\n                  >\n                    {renderRowCells()}\n                  </TableRow>\n                )}\n\n                {expandable && isExpanded && (\n                  <TableRow className=\"bg-white dark:bg-slate-800/50 hover:bg-white dark:hover:bg-slate-800/50\">\n                    <TableCell\n                      colSpan={totalColumns}\n                      className=\"p-0\"\n                      style={{ position: \"relative\" }}\n                    >\n                      <div\n                        className=\"p-4 overflow-x-auto\"\n                        style={{\n                          position: \"sticky\",\n                          left: 0,\n                          width: \"100%\",\n                          maxWidth: \"100vw\",\n                        }}\n                      >\n                        {expandable.expandedRowRender(row)}\n                      </div>\n                    </TableCell>\n                  </TableRow>\n                )}\n              </React.Fragment>\n            )\n          })\n        )}\n      </TableBody>\n    </Table>\n  )\n\n  if (columnReorderable || rowReorderable) {\n    return (\n      <DndContext\n        sensors={sensors}\n        collisionDetection={closestCenter}\n        onDragEnd={handleDragEnd}\n      >\n        {tableContent}\n      </DndContext>\n    )\n  }\n\n  return tableContent\n}\n\nexport { DataTable }\n"],"names":["DefaultEditComponent","value","onChange","onComplete","onCancel","error","inputRef","React","_a","_b","handleKeyDown","e","jsxs","jsx","Input","SortableHeaderCell","id","children","className","style","disabled","attributes","listeners","setNodeRef","transform","transition","isDragging","useSortable","dragStyle","CSS","cn","DragHandleIcon","SortableRow","isSelected","onClick","onMouseEnter","onMouseLeave","setActivatorNodeRef","DragHandleCell","hasLeftStickyColumns","dragHandleProps","DataTable","columns","data","selectable","selectedIds","onSelectionChange","sortState","onSortChange","onRowClick","onCellChange","expandable","emptyMessage","rowClassName","maxHeight","resizable","columnWidths","onColumnResize","columnReorderable","columnOrder","onColumnReorder","rowReorderableProp","onRowReorder","loading","loadingMode","loadingContent","headerGroups","rowGrouping","rowReorderable","editingCell","setEditingCell","editValue","setEditValue","editValueRef","editingCellRef","internalExpandedIds","setInternalExpandedIds","internalColumnWidths","setInternalColumnWidths","resizingColumn","setResizingColumn","resizeStartX","resizeStartWidth","internalColumnOrder","setInternalColumnOrder","col","hoveredRowIndex","setHoveredRowIndex","prev","columnKeys","next","key","missing","updated","index","currentColumnOrder","orderedColumns","sensors","useSensors","useSensor","PointerSensor","KeyboardSensor","sortableKeyboardCoordinates","handleColumnDragEnd","event","active","over","oldIndex","newIndex","newOrder","arrayMove","handleRowDragEnd","activeId","overId","row","newData","handleDragEnd","expandedRowIds","setExpandedRowIds","isAllSelected","isIndeterminate","handleSelectAll","handleSelectRow","i","handleSort","column","getSortDirection","getAlignClass","align","startEditing","rowId","columnKey","currentValue","completeEditing","result","cancelEditing","handleClickOutside","target","isEditing","isRowExpandable","isRowExpanded","toggleRowExpanded","totalColumns","rowSpanMap","middleRowSet","groupByKeys","mergeColumns","spanMap","middleRows","colKey","currentGroupValues","k","currentColValue","spanCount","j","nextGroupValues","nextColValue","v","idx","getRowSpan","rowIndex","rowMap","isGroupCellHovered","rowSpan","isGroupCellSelected","CHECKBOX_WIDTH","EXPAND_WIDTH","DRAG_HANDLE_WIDTH","getStickyStyles","getColWidth","w","parsed","leftColumns","rightColumns","dragHandleWidth","checkboxWidth","expandWidth","baseLeftOffset","leftPositions","currentLeft","rightPositions","currentRight","lastLeftSticky","firstRightSticky","isHeader","groupCellSelected","isLastLeft","isFirstRight","widthPx","baseStyles","effectiveSelected","leftPos","rightPos","getColumnWidth","handleResizeStart","currentWidth","handleResizeMove","delta","newWidth","handleResizeEnd","renderColumnHeader","stickyData","toPx","baseStyle","resizedWidth","resizeHandle","TableSortableHead","TableHead","columnsToRender","columnIds","rowIds","getDragHandleHeaderLeftOffset","getCheckboxHeaderLeftOffset","getExpandHeaderLeftOffset","offset","getHeaderGroupColSpan","group","groupedColumnsSet","g","tableContent","Table","TableHeader","TableRow","Checkbox","groupedColumns","elements","groupFirstCol","c","colSpan","SortableContext","horizontalListSortingStrategy","TableBody","TableCell","containerHeight","skeletonRowCount","_","rowIdx","Skeleton","colWidth","skeletonWidth","SplashScreen","verticalListSortingStrategy","canExpand","isExpanded","rowSortableId","renderRowCells","Fragment","DownIcon","RightIcon","cellIsEditing","hasRowSpan","groupCellHovered","bodyCellStyle","cellStyle","EditComponent","newValue","content","WriteIcon","isGroupSpanToEnd","DndContext","closestCenter"],"mappings":"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"}