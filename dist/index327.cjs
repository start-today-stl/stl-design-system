"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const e=require("./index328.cjs");function V(n,t,g){let{reference:l,floating:m}=n;const i=e.getSideAxis(t),o=e.getAlignmentAxis(t),c=e.getAxisLength(o),u=e.getSide(t),v=i==="y",f=l.x+l.width/2-m.width/2,a=l.y+l.height/2-m.height/2,d=l[c]/2-m[c]/2;let s;switch(u){case"top":s={x:f,y:l.y-m.height};break;case"bottom":s={x:f,y:l.y+l.height};break;case"right":s={x:l.x+l.width,y:a};break;case"left":s={x:l.x-m.width,y:a};break;default:s={x:l.x,y:l.y}}switch(e.getAlignment(t)){case"start":s[o]-=d*(g&&v?-1:1);break;case"end":s[o]+=d*(g&&v?-1:1);break}return s}async function W(n,t){var g;t===void 0&&(t={});const{x:l,y:m,platform:i,rects:o,elements:c,strategy:u}=n,{boundary:v="clippingAncestors",rootBoundary:f="viewport",elementContext:a="floating",altBoundary:d=!1,padding:s=0}=e.evaluate(t,n),r=e.getPaddingObject(s),x=c[d?a==="floating"?"reference":"floating":a],A=e.rectToClientRect(await i.getClippingRect({element:(g=await(i.isElement==null?void 0:i.isElement(x)))==null||g?x:x.contextElement||await(i.getDocumentElement==null?void 0:i.getDocumentElement(c.floating)),boundary:v,rootBoundary:f,strategy:u})),y=a==="floating"?{x:l,y:m,width:o.floating.width,height:o.floating.height}:o.reference,h=await(i.getOffsetParent==null?void 0:i.getOffsetParent(c.floating)),p=await(i.isElement==null?void 0:i.isElement(h))?await(i.getScale==null?void 0:i.getScale(h))||{x:1,y:1}:{x:1,y:1},b=e.rectToClientRect(i.convertOffsetParentRelativeRectToViewportRelativeRect?await i.convertOffsetParentRelativeRectToViewportRelativeRect({elements:c,rect:y,offsetParent:h,strategy:u}):y);return{top:(A.top-b.top+r.top)/p.y,bottom:(b.bottom-A.bottom+r.bottom)/p.y,left:(A.left-b.left+r.left)/p.x,right:(b.right-A.right+r.right)/p.x}}const X=async(n,t,g)=>{const{placement:l="bottom",strategy:m="absolute",middleware:i=[],platform:o}=g,c=i.filter(Boolean),u=await(o.isRTL==null?void 0:o.isRTL(t));let v=await o.getElementRects({reference:n,floating:t,strategy:m}),{x:f,y:a}=V(v,l,u),d=l,s={},r=0;for(let x=0;x<c.length;x++){var w;const{name:A,fn:y}=c[x],{x:h,y:p,data:b,reset:O}=await y({x:f,y:a,initialPlacement:l,placement:d,strategy:m,middlewareData:s,rects:v,platform:{...o,detectOverflow:(w=o.detectOverflow)!=null?w:W},elements:{reference:n,floating:t}});f=h??f,a=p??a,s={...s,[A]:{...s[A],...b}},O&&r<=50&&(r++,typeof O=="object"&&(O.placement&&(d=O.placement),O.rects&&(v=O.rects===!0?await o.getElementRects({reference:n,floating:t,strategy:m}):O.rects),{x:f,y:a}=V(v,d,u)),x=-1)}return{x:f,y:a,placement:d,strategy:m,middlewareData:s}},_=n=>({name:"arrow",options:n,async fn(t){const{x:g,y:l,placement:m,rects:i,platform:o,elements:c,middlewareData:u}=t,{element:v,padding:f=0}=e.evaluate(n,t)||{};if(v==null)return{};const a=e.getPaddingObject(f),d={x:g,y:l},s=e.getAlignmentAxis(m),r=e.getAxisLength(s),w=await o.getDimensions(v),x=s==="y",A=x?"top":"left",y=x?"bottom":"right",h=x?"clientHeight":"clientWidth",p=i.reference[r]+i.reference[s]-d[s]-i.floating[r],b=d[s]-i.reference[s],O=await(o.getOffsetParent==null?void 0:o.getOffsetParent(v));let C=O?O[h]:0;(!C||!await(o.isElement==null?void 0:o.isElement(O)))&&(C=c.floating[h]||i.floating[r]);const M=p/2-b/2,D=C/2-w[r]/2-1,P=e.min(a[A],D),L=e.min(a[y],D),T=P,H=C-w[r]-L,S=C/2-w[r]/2+M,F=e.clamp(T,S,H),E=!u.arrow&&e.getAlignment(m)!=null&&S!==F&&i.reference[r]/2-(S<T?P:L)-w[r]/2<0,R=E?S<T?S-T:S-H:0;return{[s]:d[s]+R,data:{[s]:F,centerOffset:S-F-R,...E&&{alignmentOffset:R}},reset:E}}}),q=function(n){return n===void 0&&(n={}),{name:"flip",options:n,async fn(t){var g,l;const{placement:m,middlewareData:i,rects:o,initialPlacement:c,platform:u,elements:v}=t,{mainAxis:f=!0,crossAxis:a=!0,fallbackPlacements:d,fallbackStrategy:s="bestFit",fallbackAxisSideDirection:r="none",flipAlignment:w=!0,...x}=e.evaluate(n,t);if((g=i.arrow)!=null&&g.alignmentOffset)return{};const A=e.getSide(m),y=e.getSideAxis(c),h=e.getSide(c)===c,p=await(u.isRTL==null?void 0:u.isRTL(v.floating)),b=d||(h||!w?[e.getOppositePlacement(c)]:e.getExpandedPlacements(c)),O=r!=="none";!d&&O&&b.push(...e.getOppositeAxisPlacements(c,w,r,p));const C=[c,...b],M=await u.detectOverflow(t,x),D=[];let P=((l=i.flip)==null?void 0:l.overflows)||[];if(f&&D.push(M[A]),a){const S=e.getAlignmentSides(m,o,p);D.push(M[S[0]],M[S[1]])}if(P=[...P,{placement:m,overflows:D}],!D.every(S=>S<=0)){var L,T;const S=(((L=i.flip)==null?void 0:L.index)||0)+1,F=C[S];if(F&&(!(a==="alignment"?y!==e.getSideAxis(F):!1)||P.every(k=>e.getSideAxis(k.placement)===y?k.overflows[0]>0:!0)))return{data:{index:S,overflows:P},reset:{placement:F}};let E=(T=P.filter(R=>R.overflows[0]<=0).sort((R,k)=>R.overflows[1]-k.overflows[1])[0])==null?void 0:T.placement;if(!E)switch(s){case"bestFit":{var H;const R=(H=P.filter(k=>{if(O){const j=e.getSideAxis(k.placement);return j===y||j==="y"}return!0}).map(k=>[k.placement,k.overflows.filter(j=>j>0).reduce((j,$)=>j+$,0)]).sort((k,j)=>k[1]-j[1])[0])==null?void 0:H[0];R&&(E=R);break}case"initialPlacement":E=c;break}if(m!==E)return{reset:{placement:E}}}return{}}}};function B(n,t){return{top:n.top-t.height,right:n.right-t.width,bottom:n.bottom-t.height,left:n.left-t.width}}function z(n){return e.sides.some(t=>n[t]>=0)}const I=function(n){return n===void 0&&(n={}),{name:"hide",options:n,async fn(t){const{rects:g,platform:l}=t,{strategy:m="referenceHidden",...i}=e.evaluate(n,t);switch(m){case"referenceHidden":{const o=await l.detectOverflow(t,{...i,elementContext:"reference"}),c=B(o,g.reference);return{data:{referenceHiddenOffsets:c,referenceHidden:z(c)}}}case"escaped":{const o=await l.detectOverflow(t,{...i,altBoundary:!0}),c=B(o,g.floating);return{data:{escapedOffsets:c,escaped:z(c)}}}default:return{}}}}},Y=new Set(["left","top"]);async function U(n,t){const{placement:g,platform:l,elements:m}=n,i=await(l.isRTL==null?void 0:l.isRTL(m.floating)),o=e.getSide(g),c=e.getAlignment(g),u=e.getSideAxis(g)==="y",v=Y.has(o)?-1:1,f=i&&u?-1:1,a=e.evaluate(t,n);let{mainAxis:d,crossAxis:s,alignmentAxis:r}=typeof a=="number"?{mainAxis:a,crossAxis:0,alignmentAxis:null}:{mainAxis:a.mainAxis||0,crossAxis:a.crossAxis||0,alignmentAxis:a.alignmentAxis};return c&&typeof r=="number"&&(s=c==="end"?r*-1:r),u?{x:s*f,y:d*v}:{x:d*v,y:s*f}}const G=function(n){return n===void 0&&(n=0),{name:"offset",options:n,async fn(t){var g,l;const{x:m,y:i,placement:o,middlewareData:c}=t,u=await U(t,n);return o===((g=c.offset)==null?void 0:g.placement)&&(l=c.arrow)!=null&&l.alignmentOffset?{}:{x:m+u.x,y:i+u.y,data:{...u,placement:o}}}}},J=function(n){return n===void 0&&(n={}),{name:"shift",options:n,async fn(t){const{x:g,y:l,placement:m,platform:i}=t,{mainAxis:o=!0,crossAxis:c=!1,limiter:u={fn:A=>{let{x:y,y:h}=A;return{x:y,y:h}}},...v}=e.evaluate(n,t),f={x:g,y:l},a=await i.detectOverflow(t,v),d=e.getSideAxis(e.getSide(m)),s=e.getOppositeAxis(d);let r=f[s],w=f[d];if(o){const A=s==="y"?"top":"left",y=s==="y"?"bottom":"right",h=r+a[A],p=r-a[y];r=e.clamp(h,r,p)}if(c){const A=d==="y"?"top":"left",y=d==="y"?"bottom":"right",h=w+a[A],p=w-a[y];w=e.clamp(h,w,p)}const x=u.fn({...t,[s]:r,[d]:w});return{...x,data:{x:x.x-g,y:x.y-l,enabled:{[s]:o,[d]:c}}}}}},K=function(n){return n===void 0&&(n={}),{options:n,fn(t){const{x:g,y:l,placement:m,rects:i,middlewareData:o}=t,{offset:c=0,mainAxis:u=!0,crossAxis:v=!0}=e.evaluate(n,t),f={x:g,y:l},a=e.getSideAxis(m),d=e.getOppositeAxis(a);let s=f[d],r=f[a];const w=e.evaluate(c,t),x=typeof w=="number"?{mainAxis:w,crossAxis:0}:{mainAxis:0,crossAxis:0,...w};if(u){const h=d==="y"?"height":"width",p=i.reference[d]-i.floating[h]+x.mainAxis,b=i.reference[d]+i.reference[h]-x.mainAxis;s<p?s=p:s>b&&(s=b)}if(v){var A,y;const h=d==="y"?"width":"height",p=Y.has(e.getSide(m)),b=i.reference[a]-i.floating[h]+(p&&((A=o.offset)==null?void 0:A[a])||0)+(p?0:x.crossAxis),O=i.reference[a]+i.reference[h]+(p?0:((y=o.offset)==null?void 0:y[a])||0)-(p?x.crossAxis:0);r<b?r=b:r>O&&(r=O)}return{[d]:s,[a]:r}}}},N=function(n){return n===void 0&&(n={}),{name:"size",options:n,async fn(t){var g,l;const{placement:m,rects:i,platform:o,elements:c}=t,{apply:u=()=>{},...v}=e.evaluate(n,t),f=await o.detectOverflow(t,v),a=e.getSide(m),d=e.getAlignment(m),s=e.getSideAxis(m)==="y",{width:r,height:w}=i.floating;let x,A;a==="top"||a==="bottom"?(x=a,A=d===(await(o.isRTL==null?void 0:o.isRTL(c.floating))?"start":"end")?"left":"right"):(A=a,x=d==="end"?"top":"bottom");const y=w-f.top-f.bottom,h=r-f.left-f.right,p=e.min(w-f[x],y),b=e.min(r-f[A],h),O=!t.middlewareData.shift;let C=p,M=b;if((g=t.middlewareData.shift)!=null&&g.enabled.x&&(M=h),(l=t.middlewareData.shift)!=null&&l.enabled.y&&(C=y),O&&!d){const P=e.max(f.left,0),L=e.max(f.right,0),T=e.max(f.top,0),H=e.max(f.bottom,0);s?M=r-2*(P!==0||L!==0?P+L:e.max(f.left,f.right)):C=w-2*(T!==0||H!==0?T+H:e.max(f.top,f.bottom))}await u({...t,availableWidth:M,availableHeight:C});const D=await o.getDimensions(c.floating);return r!==D.width||w!==D.height?{reset:{rects:!0}}:{}}}};exports.rectToClientRect=e.rectToClientRect;exports.arrow=_;exports.computePosition=X;exports.detectOverflow=W;exports.flip=q;exports.hide=I;exports.limitShift=K;exports.offset=G;exports.shift=J;exports.size=N;
//# sourceMappingURL=index327.cjs.map
